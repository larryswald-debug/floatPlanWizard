<cfcomponent output="false">

    <cffunction name="handle" access="remote" returntype="void" output="true">
        <cfargument name="action" type="string" required="false" default="getTimeline">
        <cfargument name="routeCode" type="string" required="false" default="">
        <cfargument name="segmentId" type="numeric" required="false" default="0">
        <cfargument name="direction" type="string" required="false" default="">
        <cfsetting enablecfoutputonly="true" showdebugoutput="false">
        <cfcontent type="application/json; charset=utf-8">
        <cfheader name="Cache-Control" value="no-store, no-cache, must-revalidate">

        <cftry>
            <cfset var userStruct = {} />
            <cfif structKeyExists(session, "user") AND isStruct(session.user)>
                <cfset userStruct = session.user />
            </cfif>
            <cfset var userId = resolveUserId(userStruct) />

            <cfif userId LTE 0>
                <cfoutput>#serializeJSON({
                    "SUCCESS"=false,
                    "AUTH"=false,
                    "MESSAGE"="Unauthorized",
                    "ERROR"={"MESSAGE"="No logged-in user session."}
                })#</cfoutput>
                <cfreturn>
            </cfif>

            <cfset var body = getBodyJson() />
            <cfset var act = lCase(trim(arguments.action)) />

            <cfif act EQ "generateroute">
                <cfset var startDate = pickArg(body, "startDate", "startDate", "") />
                <cfset var startLocation = pickArg(body, "startLocation", "startLocation", "") />
                <cfset var endLocation = pickArg(body, "endLocation", "endLocation", "") />
                <cfset var directionArg = pickArg(body, "direction", "direction", "CCW") />
                <cfset var tripType = pickArg(body, "tripType", "tripType", "POINT_TO_POINT") />
                <cfset var generated = generateRoute(userId, startDate, startLocation, endLocation, directionArg, tripType) />
                <cfoutput>#serializeJSON(generated)#</cfoutput>
                <cfreturn>

            <cfelseif act EQ "listroutetemplates">
                <cfset var templates = listRouteTemplates() />
                <cfoutput>#serializeJSON(templates)#</cfoutput>
                <cfreturn>

            <cfelseif act EQ "getroutetemplatepreview">
                <cfset var previewRouteId = val(pickArg(body, "routeId", "routeId", 0)) />
                <cfset var previewRouteCode = trim(pickArg(body, "routeCode", "routeCode", "")) />
                <cfset var previewDirection = trim(pickArg(body, "direction", "direction", "CCW")) />
                <cfset var preview = getRouteTemplatePreview(previewRouteId, previewRouteCode, previewDirection) />
                <cfoutput>#serializeJSON(preview)#</cfoutput>
                <cfreturn>

            <cfelseif act EQ "getroutetemplatedetours">
                <cfset var detourRouteId = val(pickArg(body, "routeId", "routeId", 0)) />
                <cfset var detourRouteCode = trim(pickArg(body, "routeCode", "routeCode", "")) />
                <cfset var detours = getRouteTemplateDetours(detourRouteId, detourRouteCode) />
                <cfoutput>#serializeJSON(detours)#</cfoutput>
                <cfreturn>

            <cfelseif act EQ "generateroutefromtemplate">
                <cfset var templateRouteId = val(pickArg(body, "templateRouteId", "template_route_id", 0)) />
                <cfset var templateRouteCode = trim(pickArg(body, "templateRouteCode", "template_route_code", "")) />
                <cfset var templateDirection = trim(pickArg(body, "direction", "direction", "CCW")) />
                <cfset var templateMode = trim(pickArg(body, "mode", "mode", "FULL_TEMPLATE")) />
                <cfset var templateName = trim(pickArg(body, "routeName", "route_name", "")) />
                <cfset var templateSetActive = toBoolean(pickArg(body, "setActive", "set_active", true), true) />
                <cfset var generatedFromTemplate = generateRouteFromTemplate(
                    userId = userId,
                    templateRouteId = templateRouteId,
                    templateRouteCode = templateRouteCode,
                    direction = templateDirection,
                    mode = templateMode,
                    routeName = templateName,
                    setActive = templateSetActive
                ) />
                <cfoutput>#serializeJSON(generatedFromTemplate)#</cfoutput>
                <cfreturn>

            <cfelseif act EQ "listuserroutes">
                <cfset var listed = listUserRoutes(userId) />
                <cfoutput>#serializeJSON(listed)#</cfoutput>
                <cfreturn>

            <cfelseif act EQ "listcanonicallocations">
                <cfset var canonicalDirection = pickArg(body, "direction", "direction", "CCW") />
                <cfset var canonical = listCanonicalLocations(canonicalDirection) />
                <cfoutput>#serializeJSON(canonical)#</cfoutput>
                <cfreturn>

            <cfelseif act EQ "buildfloatplansfromroute">
                <cfset var buildRouteInstanceId = val(pickArg(body, "routeInstanceId", "route_instance_id", 0)) />
                <cfset var buildRouteCode = trim(pickArg(body, "routeCode", "route_code", "")) />
                <cfset var buildMode = trim(pickArg(body, "mode", "mode", "DAILY")) />
                <cfset var buildVesselId = val(pickArg(body, "vesselId", "vessel_id", 0)) />
                <cfset var buildRebuild = pickArg(body, "rebuild", "rebuild", false) />
                <cfset var built = buildFloatPlansFromRoute(
                    userId = userId,
                    routeInstanceId = buildRouteInstanceId,
                    routeCode = buildRouteCode,
                    mode = buildMode,
                    vesselId = buildVesselId,
                    rebuild = buildRebuild
                ) />
                <cfoutput>#serializeJSON(built)#</cfoutput>
                <cfreturn>

            <cfelseif act EQ "setactiveroute">
                <cfset var activeCode = trim(arguments.routeCode) />
                <cfif NOT len(activeCode)>
                    <cfset activeCode = trim(pickArg(body, "routeCode", "routeCode", "")) />
                </cfif>
                <cfif NOT len(activeCode)>
                    <cfoutput>#serializeJSON({
                        "SUCCESS"=false,
                        "AUTH"=true,
                        "MESSAGE"="routeCode required",
                        "ERROR"={"MESSAGE"="routeCode is required"}
                    })#</cfoutput>
                    <cfreturn>
                </cfif>
                <cfset var activeRes = setActiveRoute(userId, activeCode) />
                <cfoutput>#serializeJSON(activeRes)#</cfoutput>
                <cfreturn>

            <cfelseif act EQ "deleteroute">
                <cfset var deleteCode = trim(arguments.routeCode) />
                <cfif NOT len(deleteCode)>
                    <cfset deleteCode = trim(pickArg(body, "routeCode", "routeCode", "")) />
                </cfif>
                <cfif NOT len(deleteCode)>
                    <cfoutput>#serializeJSON({
                        "SUCCESS"=false,
                        "AUTH"=true,
                        "MESSAGE"="routeCode required",
                        "ERROR"={"MESSAGE"="routeCode is required"}
                    })#</cfoutput>
                    <cfreturn>
                </cfif>
                <cfset var deleteRes = deleteRoute(userId, deleteCode) />
                <cfoutput>#serializeJSON(deleteRes)#</cfoutput>
                <cfreturn>

            <cfelseif act EQ "gettimeline">
                <cfset var rcode = trim(arguments.routeCode) />
                <cfif NOT len(rcode)>
                    <cfset rcode = trim(pickArg(body, "routeCode", "routeCode", "")) />
                </cfif>
                <cfif NOT len(rcode)>
                    <cfoutput>#serializeJSON({
                        "SUCCESS"=false,
                        "AUTH"=true,
                        "MESSAGE"="routeCode required",
                        "ERROR"={"MESSAGE"="routeCode is required"}
                    })#</cfoutput>
                    <cfreturn>
                </cfif>
                <cfset var tl = getTimeline(userId, rcode) />
                <cfoutput>#serializeJSON(tl)#</cfoutput>
                <cfreturn>

            <cfelseif act EQ "updatesegment">
                <cfset var segIdLocal = val(arguments.segmentId) />
                <cfif segIdLocal LTE 0>
                    <cfset segIdLocal = val(pickArg(body, "segmentId", "segmentId", 0)) />
                </cfif>
                <cfset var rc = trim(arguments.routeCode) />
                <cfif NOT len(rc)>
                    <cfset rc = trim(pickArg(body, "routeCode", "routeCode", "")) />
                </cfif>
                <cfif segIdLocal LTE 0 OR NOT len(rc)>
                    <cfoutput>#serializeJSON({
                        "SUCCESS"=false,
                        "AUTH"=true,
                        "MESSAGE"="segmentId and routeCode required",
                        "ERROR"={"MESSAGE"="segmentId and routeCode are required"}
                    })#</cfoutput>
                    <cfreturn>
                </cfif>
                <cfset var upd = updateSegment(userId, rc, segIdLocal, body) />
                <cfoutput>#serializeJSON(upd)#</cfoutput>
                <cfreturn>

            <cfelse>
                <cfoutput>#serializeJSON({
                    "SUCCESS"=false,
                    "AUTH"=true,
                    "MESSAGE"="Unknown action",
                    "ERROR"={"MESSAGE"="Unsupported action: " & arguments.action}
                })#</cfoutput>
                <cfreturn>
            </cfif>

            <cfcatch>
                <cfoutput>#serializeJSON({
                    "SUCCESS"=false,
                    "AUTH"=true,
                    "MESSAGE"="Application error",
                    "ERROR"={"MESSAGE"=cfcatch.message, "DETAIL"=cfcatch.detail}
                })#</cfoutput>
            </cfcatch>
        </cftry>
    </cffunction>

    <cffunction name="listRouteTemplates" access="private" returntype="struct" output="false">
        <cfscript>
            var out = {
                "SUCCESS"=true,
                "AUTH"=true,
                "MESSAGE"="OK",
                "DATA"={ "ROUTES"=[] }
            };
            var qTemplates = queryExecute(
                "SELECT id, code, name, description, short_code, version, is_default
                 FROM loop_routes
                 WHERE is_active = 1
                   AND short_code NOT LIKE :userPrefix
                 ORDER BY is_default DESC, name ASC, id ASC",
                {
                    userPrefix = { value="USER_ROUTE_%", cfsqltype="cf_sql_varchar" }
                },
                { datasource = application.dsn }
            );
            var i = 0;
            for (i = 1; i LTE qTemplates.recordCount; i++) {
                arrayAppend(out.DATA.ROUTES, {
                    "ID"=val(qTemplates.id[i]),
                    "CODE"=(isNull(qTemplates.code[i]) ? "" : toString(qTemplates.code[i])),
                    "NAME"=(isNull(qTemplates.name[i]) ? "" : toString(qTemplates.name[i])),
                    "DESCRIPTION"=(isNull(qTemplates.description[i]) ? "" : toString(qTemplates.description[i])),
                    "SHORT_CODE"=(isNull(qTemplates.short_code[i]) ? "" : toString(qTemplates.short_code[i])),
                    "VERSION"=(isNull(qTemplates.version[i]) ? 0 : val(qTemplates.version[i])),
                    "IS_DEFAULT"=(qTemplates.is_default[i] EQ 1)
                });
            }
            return out;
        </cfscript>
    </cffunction>

    <cffunction name="generateRoute" access="private" returntype="struct" output="false">
        <cfargument name="userId" type="numeric" required="true">
        <cfargument name="startDate" type="string" required="true">
        <cfargument name="startLocation" type="string" required="true">
        <cfargument name="endLocation" type="string" required="true">
        <cfargument name="direction" type="string" required="false" default="CCW">
        <cfargument name="tripType" type="string" required="false" default="POINT_TO_POINT">
        <cfscript>
            var out = { "SUCCESS"=true, "AUTH"=true, "MESSAGE"="OK", "WARNINGS"=[] };
            var milepointService = getMilepointService();
            var rmAutoFillCount = 0;
            var rmUnresolvedCount = 0;
            var tripTypeVal = normalizeTripType(arguments.tripType);
            var startDateVal = trim(arguments.startDate);
            var startLocRaw = trim(arguments.startLocation);
            var endLocRaw = trim(arguments.endLocation);
            if (!len(startDateVal) OR !len(startLocRaw)) {
                return {
                    "SUCCESS"=false,
                    "AUTH"=true,
                    "MESSAGE"="Missing required fields",
                    "ERROR"={"MESSAGE"="startDate and startLocation are required"}
                };
            }
            if (tripTypeVal NEQ "FULL_LOOP" AND !len(endLocRaw)) {
                return {
                    "SUCCESS"=false,
                    "AUTH"=true,
                    "MESSAGE"="Missing required fields",
                    "ERROR"={"MESSAGE"="endLocation is required for point-to-point routes"}
                };
            }
            if (tripTypeVal EQ "FULL_LOOP") {
                endLocRaw = startLocRaw;
            }

            var qTpl = queryExecute(
                "SELECT id, name, short_code, description
                 FROM loop_routes
                 WHERE short_code = 'GREAT_LOOP_CCW'
                 LIMIT 1",
                {},
                { datasource = application.dsn }
            );
            if (qTpl.recordCount EQ 0) {
                return {
                    "SUCCESS"=false,
                    "AUTH"=true,
                    "MESSAGE"="Template route not found",
                    "ERROR"={"MESSAGE"="GREAT_LOOP_CCW was not found in loop_routes"}
                };
            }

            var templateRouteId = qTpl.id[1];
            var directionVal = normalizeDirection(arguments.direction);
            var shortCode = "USER_ROUTE_" & int(arguments.userId) & "_" & dateTimeFormat(now(), "yyyymmddHHnnss");
            var routeName = "My Great Loop Route";
            var routeDesc = "Generated from GREAT_LOOP_CCW (" & directionVal & ") on " & dateFormat(now(), "yyyy-mm-dd") & " (" & startLocRaw & " to " & endLocRaw & ")";

            var qTplSections = queryExecute(
                "SELECT id, name, slug, short_code, phase_num, order_index, is_active_default
                 FROM loop_sections
                 WHERE route_id = :rid
                 ORDER BY order_index ASC",
                { rid = { value=templateRouteId, cfsqltype="cf_sql_integer" } },
                { datasource = application.dsn }
            );

            var qTplSegments = queryExecute(
                "SELECT s.id, s.section_id, s.order_index, s.start_name, s.end_name, s.dist_nm, s.lock_count, s.rm_start, s.rm_end, s.is_signature_event, s.is_milestone_end, s.notes,
                        sec.order_index AS section_order
                 FROM loop_segments s
                 INNER JOIN loop_sections sec ON sec.id = s.section_id
                 WHERE sec.route_id = :rid
                 ORDER BY sec.order_index ASC, s.order_index ASC",
                { rid = { value=templateRouteId, cfsqltype="cf_sql_integer" } },
                { datasource = application.dsn }
            );

            var segmentRows = [];
            var routeOrderCounter = 0;
            var segIdx = 0;
            if (directionVal EQ "CW") {
                for (segIdx = qTplSegments.recordCount; segIdx GTE 1; segIdx--) {
                    routeOrderCounter += 1;
                    arrayAppend(segmentRows, {
                        "TEMPLATE_SEGMENT_ID"=qTplSegments.id[segIdx],
                        "SECTION_ID"=qTplSegments.section_id[segIdx],
                        "ORDER_INDEX"=qTplSegments.order_index[segIdx],
                        "SECTION_ORDER"=qTplSegments.section_order[segIdx],
                        "START_NAME"=qTplSegments.end_name[segIdx],
                        "END_NAME"=qTplSegments.start_name[segIdx],
                        "DIST_NM"=qTplSegments.dist_nm[segIdx],
                        "LOCK_COUNT"=qTplSegments.lock_count[segIdx],
                        "RM_START"=qTplSegments.rm_end[segIdx],
                        "RM_END"=qTplSegments.rm_start[segIdx],
                        "IS_SIGNATURE_EVENT"=qTplSegments.is_signature_event[segIdx],
                        "IS_MILESTONE_END"=qTplSegments.is_milestone_end[segIdx],
                        "NOTES"=qTplSegments.notes[segIdx],
                        "ROUTE_ORDER"=routeOrderCounter
                    });
                }
            } else {
                for (segIdx = 1; segIdx LTE qTplSegments.recordCount; segIdx++) {
                    routeOrderCounter += 1;
                    arrayAppend(segmentRows, {
                        "TEMPLATE_SEGMENT_ID"=qTplSegments.id[segIdx],
                        "SECTION_ID"=qTplSegments.section_id[segIdx],
                        "ORDER_INDEX"=qTplSegments.order_index[segIdx],
                        "SECTION_ORDER"=qTplSegments.section_order[segIdx],
                        "START_NAME"=qTplSegments.start_name[segIdx],
                        "END_NAME"=qTplSegments.end_name[segIdx],
                        "DIST_NM"=qTplSegments.dist_nm[segIdx],
                        "LOCK_COUNT"=qTplSegments.lock_count[segIdx],
                        "RM_START"=qTplSegments.rm_start[segIdx],
                        "RM_END"=qTplSegments.rm_end[segIdx],
                        "IS_SIGNATURE_EVENT"=qTplSegments.is_signature_event[segIdx],
                        "IS_MILESTONE_END"=qTplSegments.is_milestone_end[segIdx],
                        "NOTES"=qTplSegments.notes[segIdx],
                        "ROUTE_ORDER"=routeOrderCounter
                    });
                }
            }

            if (arrayLen(segmentRows) LTE 0) {
                return {
                    "SUCCESS"=false,
                    "AUTH"=true,
                    "MESSAGE"="Template route has no segments",
                    "ERROR"={"MESSAGE"="GREAT_LOOP_CCW has no loop_segments to generate from."}
                };
            }

            var matchInfo = findFocusSegments(templateRouteId, startLocRaw, endLocRaw, directionVal);
            var trimStartOrder = 0;
            var trimEndOrder = 0;
            var endFallbackUsed = false;
            var wrapRangeUsed = false;
            var selectedSegmentRows = [];
            var selectedIdx = 0;
            var fullLoopPick = {};
            var pointToPointPick = {};
            if (!matchInfo.START_FOUND OR val(matchInfo.START_ORDER) LTE 0) {
                return {
                    "SUCCESS"=false,
                    "AUTH"=true,
                    "MESSAGE"="Start location not found in route template",
                    "ERROR"={"MESSAGE"="The selected start location could not be matched in GREAT_LOOP_CCW (" & directionVal & ")."}
                };
            }
            trimStartOrder = val(matchInfo.START_ORDER);

            if (tripTypeVal EQ "FULL_LOOP") {
                fullLoopPick = pickBestFullLoopSelection(segmentRows, startLocRaw, trimStartOrder);
                if (fullLoopPick.SUCCESS) {
                    selectedSegmentRows = fullLoopPick.ROWS;
                    trimStartOrder = fullLoopPick.START_ORDER;
                    trimEndOrder = fullLoopPick.END_ORDER;
                } else {
                    for (selectedIdx = trimStartOrder; selectedIdx LTE arrayLen(segmentRows); selectedIdx++) {
                        arrayAppend(selectedSegmentRows, segmentRows[selectedIdx]);
                    }
                    for (selectedIdx = 1; selectedIdx LT trimStartOrder; selectedIdx++) {
                        arrayAppend(selectedSegmentRows, segmentRows[selectedIdx]);
                    }
                    if (arrayLen(selectedSegmentRows) GT 0) {
                        trimEndOrder = selectedSegmentRows[arrayLen(selectedSegmentRows)].ROUTE_ORDER;
                    } else {
                        trimEndOrder = 0;
                    }
                }
            } else {
                pointToPointPick = pickBestPointToPointSelection(segmentRows, startLocRaw, endLocRaw, trimStartOrder);
                if (pointToPointPick.SUCCESS) {
                    selectedSegmentRows = pointToPointPick.ROWS;
                    trimStartOrder = pointToPointPick.START_ORDER;
                    trimEndOrder = pointToPointPick.END_ORDER;
                    wrapRangeUsed = pointToPointPick.WRAP_RANGE;
                } else {
                    if (!matchInfo.END_FOUND OR val(matchInfo.END_ORDER) LTE 0) {
                        trimEndOrder = segmentRows[arrayLen(segmentRows)].ROUTE_ORDER;
                        endFallbackUsed = true;
                    } else {
                        trimEndOrder = val(matchInfo.END_ORDER);
                    }

                    if (trimEndOrder GTE trimStartOrder) {
                        for (selectedIdx = trimStartOrder; selectedIdx LTE trimEndOrder; selectedIdx++) {
                            arrayAppend(selectedSegmentRows, segmentRows[selectedIdx]);
                        }
                    } else {
                        wrapRangeUsed = true;
                        for (selectedIdx = trimStartOrder; selectedIdx LTE arrayLen(segmentRows); selectedIdx++) {
                            arrayAppend(selectedSegmentRows, segmentRows[selectedIdx]);
                        }
                        for (selectedIdx = 1; selectedIdx LTE trimEndOrder; selectedIdx++) {
                            arrayAppend(selectedSegmentRows, segmentRows[selectedIdx]);
                        }
                    }
                }
            }

            if (arrayLen(selectedSegmentRows) EQ 0) {
                return {
                    "SUCCESS"=false,
                    "AUTH"=true,
                    "MESSAGE"="Unable to build route range from selected start/end",
                    "ERROR"={"MESSAGE"="Could not resolve a valid contiguous route range from your selected start and end locations."}
                };
            }
            var continuityIssue = findRouteContinuityIssue(selectedSegmentRows);
            if (continuityIssue.HAS_BREAK) {
                return {
                    "SUCCESS"=false,
                    "AUTH"=true,
                    "MESSAGE"="Template route continuity error",
                    "ERROR"={
                        "MESSAGE"="Template continuity break between '" & continuityIssue.PREV_END_RAW & "' and '" & continuityIssue.NEXT_START_RAW & "'.",
                        "DETAIL"="GREAT_LOOP_CCW has non-contiguous segment ordering at route order " & continuityIssue.NEXT_ROUTE_ORDER & ". Update template segment ordering/data."
                    }
                };
            }

            var newRouteId = 0;
            var templateSectionInfoById = {};
            var segmentMap = {};
            var routeInstanceId = 0;
            var selectedSegIdx = 0;
            var sectionInfoIdx = 0;
            for (sectionInfoIdx = 1; sectionInfoIdx LTE qTplSections.recordCount; sectionInfoIdx++) {
                var tplSectionIdInfo = toString(qTplSections.id[sectionInfoIdx]);
                var sectionNameInfo = trim(toString(qTplSections.name[sectionInfoIdx]));
                var sectionSlugInfo = trim(toString(qTplSections.slug[sectionInfoIdx]));
                if (!len(sectionSlugInfo)) {
                    sectionSlugInfo = lCase(reReplace(sectionNameInfo, "[^A-Za-z0-9]+", "-", "all"));
                    sectionSlugInfo = reReplace(sectionSlugInfo, "^-+|-+$", "", "all");
                }
                if (!len(sectionSlugInfo)) {
                    sectionSlugInfo = "section-" & sectionInfoIdx;
                }
                var sectionShortCodeInfo = trim(toString(qTplSections.short_code[sectionInfoIdx]));
                if (!len(sectionShortCodeInfo)) {
                    sectionShortCodeInfo = uCase(reReplace(sectionSlugInfo, "[^A-Za-z0-9]+", "_", "all"));
                }
                if (!len(sectionNameInfo)) {
                    sectionNameInfo = "Section " & sectionInfoIdx;
                }
                templateSectionInfoById[tplSectionIdInfo] = {
                    "NAME"=sectionNameInfo,
                    "SLUG"=sectionSlugInfo,
                    "SHORT_CODE"=sectionShortCodeInfo,
                    "PHASE_NUM"=(isNull(qTplSections.phase_num[sectionInfoIdx]) ? 1 : val(qTplSections.phase_num[sectionInfoIdx])),
                    "IS_ACTIVE_DEFAULT"=(qTplSections.is_active_default[sectionInfoIdx] EQ 1 ? 1 : 0)
                };
            }

            transaction {
                queryExecute(
                    "INSERT INTO loop_routes (name, code, short_code, description, is_default)
                     VALUES (:name, :code, :shortCode, :descr, 0)",
                    {
                        name = { value=routeName, cfsqltype="cf_sql_varchar" },
                        code = { value=shortCode, cfsqltype="cf_sql_varchar" },
                        shortCode = { value=shortCode, cfsqltype="cf_sql_varchar" },
                        descr = { value=routeDesc, cfsqltype="cf_sql_varchar" }
                    },
                    { datasource = application.dsn, result = "routeIns" }
                );
                newRouteId = val(routeIns.generatedKey);

                var i = 0;
                var segRow = {};
                var localOrderIndex = 0;
                var currentRunOldSectionId = "";
                var currentRunSectionId = 0;
                var currentRunSegmentOrder = 0;
                var sectionRunCountByTemplate = {};
                var runNum = 0;
                var sectionInfo = {};
                var sectionNameVal = "";
                var sectionSlugVal = "";
                var sectionShortCodeVal = "";
                var sectionOrderIndex = 0;
                for (i = 1; i LTE arrayLen(selectedSegmentRows); i++) {
                    segRow = selectedSegmentRows[i];
                    var oldSecId = toString(segRow.SECTION_ID);
                    var distNmBind = toNullableNumber(segRow.DIST_NM, "numeric");
                    var lockCountBind = toNullableNumber(segRow.LOCK_COUNT, "integer");
                    var rmStartBind = toNullableNumber(segRow.RM_START, "numeric");
                    var rmEndBind = toNullableNumber(segRow.RM_END, "numeric");
                    var startNameVal = trim(toString(segRow.START_NAME));
                    var endNameVal = trim(toString(segRow.END_NAME));
                    if (!structKeyExists(templateSectionInfoById, oldSecId)) {
                        continue;
                    }

                    if (oldSecId NEQ currentRunOldSectionId) {
                        currentRunOldSectionId = oldSecId;
                        currentRunSegmentOrder = 0;
                        runNum = (structKeyExists(sectionRunCountByTemplate, oldSecId) ? sectionRunCountByTemplate[oldSecId] + 1 : 1);
                        sectionRunCountByTemplate[oldSecId] = runNum;
                        sectionInfo = templateSectionInfoById[oldSecId];
                        sectionOrderIndex = i;

                        sectionNameVal = sectionInfo.NAME;
                        if (runNum GT 1) {
                            sectionNameVal &= " (Leg " & runNum & ")";
                        }

                        sectionSlugVal = sectionInfo.SLUG;
                        if (runNum GT 1) {
                            sectionSlugVal &= "-leg-" & runNum;
                        }
                        if (len(sectionSlugVal) GT 160) {
                            sectionSlugVal = left(sectionSlugVal, 160);
                        }

                        sectionShortCodeVal = sectionInfo.SHORT_CODE;
                        if (runNum GT 1) {
                            sectionShortCodeVal &= "_" & runNum;
                        }
                        if (len(sectionShortCodeVal) GT 40) {
                            sectionShortCodeVal = left(sectionShortCodeVal, 40);
                        }
                        if (!len(sectionShortCodeVal)) {
                            sectionShortCodeVal = "SECTION_" & sectionOrderIndex;
                        }

                        queryExecute(
                            "INSERT INTO loop_sections (route_id, name, slug, short_code, phase_num, order_index, is_active_default)
                             VALUES (:rid, :name, :slug, :scode, :phaseNum, :orderIndex, :isActive)",
                            {
                                rid = { value=newRouteId, cfsqltype="cf_sql_integer" },
                                name = { value=sectionNameVal, cfsqltype="cf_sql_varchar", null = false },
                                slug = { value=sectionSlugVal, cfsqltype="cf_sql_varchar", null = false },
                                scode = { value=sectionShortCodeVal, cfsqltype="cf_sql_varchar", null = false },
                                phaseNum = { value=sectionInfo.PHASE_NUM, cfsqltype="cf_sql_integer", null = false },
                                orderIndex = { value=sectionOrderIndex, cfsqltype="cf_sql_integer" },
                                isActive = { value=(i EQ 1 ? 1 : 0), cfsqltype="cf_sql_integer" }
                            },
                            { datasource = application.dsn, result = "secIns" }
                        );
                        currentRunSectionId = val(secIns.generatedKey);
                    }

                    currentRunSegmentOrder += 1;
                    localOrderIndex = currentRunSegmentOrder;
                    if (!len(startNameVal)) {
                        startNameVal = "Unknown Start";
                    }
                    if (!len(endNameVal)) {
                        endNameVal = "Unknown End";
                    }
                    sectionInfo = templateSectionInfoById[oldSecId];
                    if (isObject(milepointService)) {
                        var rmResolved = milepointService.resolveSegmentRM(sectionInfo.NAME, startNameVal, endNameVal);
                        if ((rmStartBind.isNull OR isNullableZero(rmStartBind)) AND rmResolved.START_FOUND) {
                            rmStartBind = { "isNull"=false, "value"=rmResolved.RM_START };
                        }
                        if ((rmEndBind.isNull OR isNullableZero(rmEndBind)) AND rmResolved.END_FOUND) {
                            rmEndBind = { "isNull"=false, "value"=rmResolved.RM_END };
                        }
                        if (!len(rmResolved.WATERWAY_CODE)) {
                            if (isNullableZero(rmStartBind)) rmStartBind = { "isNull"=true, "value"=0 };
                            if (isNullableZero(rmEndBind)) rmEndBind = { "isNull"=true, "value"=0 };
                        }
                        if (rmResolved.AUTOFILLED) {
                            rmAutoFillCount += 1;
                        } else if (len(rmResolved.WATERWAY_CODE) AND (NOT rmResolved.START_FOUND OR NOT rmResolved.END_FOUND)) {
                            rmUnresolvedCount += 1;
                        }
                    }
                    queryExecute(
                        "INSERT INTO loop_segments
                            (section_id, order_index, start_name, end_name, dist_nm, lock_count, rm_start, rm_end, is_signature_event, is_milestone_end, notes)
                         VALUES
                            (:sectionId, :orderIndex, :startName, :endName, :distNm, :lockCount, :rmStart, :rmEnd, :isSignature, :isMilestone, :notes)",
                        {
                            sectionId = { value=currentRunSectionId, cfsqltype="cf_sql_integer" },
                            orderIndex = { value=localOrderIndex, cfsqltype="cf_sql_integer" },
                            startName = { value=startNameVal, cfsqltype="cf_sql_varchar", null = false },
                            endName = { value=endNameVal, cfsqltype="cf_sql_varchar", null = false },
                            distNm = { value=distNmBind.value, cfsqltype="cf_sql_decimal", null = distNmBind.isNull },
                            lockCount = { value=lockCountBind.value, cfsqltype="cf_sql_integer", null = lockCountBind.isNull },
                            rmStart = { value=rmStartBind.value, cfsqltype="cf_sql_decimal", null = rmStartBind.isNull },
                            rmEnd = { value=rmEndBind.value, cfsqltype="cf_sql_decimal", null = rmEndBind.isNull },
                            isSignature = { value=(segRow.IS_SIGNATURE_EVENT EQ 1 ? 1 : 0), cfsqltype="cf_sql_integer" },
                            isMilestone = { value=(segRow.IS_MILESTONE_END EQ 1 ? 1 : 0), cfsqltype="cf_sql_integer" },
                            notes = { value=segRow.NOTES, cfsqltype="cf_sql_varchar", null = isNull(segRow.NOTES) }
                        },
                        { datasource = application.dsn, result = "segIns" }
                    );
                    segmentMap[toString(segRow.TEMPLATE_SEGMENT_ID)] = val(segIns.generatedKey);
                }

                queryExecute(
                    "INSERT INTO user_route_progress (user_id, segment_id, status, completed_at)
                     SELECT :uid, s.id, 'NOT_STARTED', NULL
                     FROM loop_segments s
                     INNER JOIN loop_sections sec ON sec.id = s.section_id
                     WHERE sec.route_id = :rid",
                    {
                        uid = { value=arguments.userId, cfsqltype="cf_sql_integer" },
                        rid = { value=newRouteId, cfsqltype="cf_sql_integer" }
                    },
                    { datasource = application.dsn }
                );

                queryExecute(
                    "INSERT INTO route_instances
                        (user_id, template_route_code, generated_route_id, generated_route_code, direction, trip_type, start_location, end_location, status)
                     VALUES
                        (:userId, :templateCode, :generatedRouteId, :generatedRouteCode, :direction, :tripType, :startLocation, :endLocation, 'PLANNED')",
                    {
                        userId = { value=toString(arguments.userId), cfsqltype="cf_sql_varchar" },
                        templateCode = { value="GREAT_LOOP_CCW", cfsqltype="cf_sql_varchar" },
                        generatedRouteId = { value=newRouteId, cfsqltype="cf_sql_integer" },
                        generatedRouteCode = { value=shortCode, cfsqltype="cf_sql_varchar" },
                        direction = { value=directionVal, cfsqltype="cf_sql_varchar" },
                        tripType = { value=tripTypeVal, cfsqltype="cf_sql_varchar" },
                        startLocation = { value=startLocRaw, cfsqltype="cf_sql_varchar" },
                        endLocation = { value=endLocRaw, cfsqltype="cf_sql_varchar", null=NOT len(endLocRaw) }
                    },
                    { datasource = application.dsn, result = "routeInstIns" }
                );
                routeInstanceId = val(routeInstIns.generatedKey);
            }

            if (endFallbackUsed) {
                arrayAppend(out.WARNINGS, "Could not match planned end location exactly; generated from selected start to template end.");
            }
            if (wrapRangeUsed) {
                arrayAppend(out.WARNINGS, "Route range wrapped across the loop origin.");
            }
            out.TRIMMED_TO_SELECTION = true;
            out.WRAP_RANGE = wrapRangeUsed;
            out.TRIP_TYPE = tripTypeVal;

            var timeline = getTimeline(arguments.userId, shortCode);
            out.ROUTE_CODE = shortCode;
            out.ROUTE_ID = newRouteId;
            out.ROUTE_INSTANCE_ID = routeInstanceId;
            out.DIRECTION = directionVal;
            out.START_DATE = startDateVal;
            out.START_LOCATION = startLocRaw;
            out.END_LOCATION = endLocRaw;
            out.FOCUS = {
                "START_SEGMENT_ID"=(structKeyExists(segmentMap, toString(matchInfo.START_SEGMENT_ID)) ? segmentMap[toString(matchInfo.START_SEGMENT_ID)] : 0),
                "END_SEGMENT_ID"=(structKeyExists(segmentMap, toString(matchInfo.END_SEGMENT_ID)) ? segmentMap[toString(matchInfo.END_SEGMENT_ID)] : 0),
                "START_FOUND"=matchInfo.START_FOUND,
                "END_FOUND"=matchInfo.END_FOUND
            };
            session.expeditionRouteCode = shortCode;
            out.RM_AUTOFILL_COUNT = rmAutoFillCount;
            out.RM_UNRESOLVED_COUNT = rmUnresolvedCount;
            structAppend(out, timeline, true);
            return out;
        </cfscript>
    </cffunction>

    <cffunction name="getRouteTemplatePreview" access="private" returntype="struct" output="false">
        <cfargument name="routeId" type="numeric" required="false" default="0">
        <cfargument name="routeCode" type="string" required="false" default="">
        <cfargument name="direction" type="string" required="false" default="CCW">
        <cfscript>
            var out = {
                "SUCCESS"=false,
                "AUTH"=true,
                "MESSAGE"="Route template preview unavailable",
                "DATA"={ "ROUTE"={}, "SEGMENTS"=[] }
            };
            var routeIdVal = val(arguments.routeId);
            var routeCodeVal = trim(arguments.routeCode);
            var directionVal = normalizeDirection(arguments.direction);
            var qRoute = queryNew("");
            var qSegments = queryNew("");
            var i = 0;
            var srcIdx = 0;
            var segObj = {};

            if (routeIdVal LTE 0 AND !len(routeCodeVal)) {
                out.MESSAGE = "Missing required fields";
                out.ERROR = { "MESSAGE"="routeId or routeCode is required." };
                return out;
            }

            if (routeIdVal GT 0) {
                qRoute = queryExecute(
                    "SELECT id, code, name, description, short_code
                     FROM loop_routes
                     WHERE id = :rid
                       AND is_active = 1
                       AND short_code NOT LIKE :userPrefix
                     LIMIT 1",
                    {
                        rid = { value=routeIdVal, cfsqltype="cf_sql_integer" },
                        userPrefix = { value="USER_ROUTE_%", cfsqltype="cf_sql_varchar" }
                    },
                    { datasource = application.dsn }
                );
            } else {
                qRoute = queryExecute(
                    "SELECT id, code, name, description, short_code
                     FROM loop_routes
                     WHERE is_active = 1
                       AND short_code NOT LIKE :userPrefix
                       AND (short_code = :rcode OR code = :rcode)
                     ORDER BY CASE WHEN short_code = :rcode THEN 0 ELSE 1 END, id ASC
                     LIMIT 1",
                    {
                        userPrefix = { value="USER_ROUTE_%", cfsqltype="cf_sql_varchar" },
                        rcode = { value=routeCodeVal, cfsqltype="cf_sql_varchar" }
                    },
                    { datasource = application.dsn }
                );
            }

            if (qRoute.recordCount EQ 0) {
                out.MESSAGE = "Route template not found";
                out.ERROR = { "MESSAGE"="No active canonical route template matched the provided routeId/routeCode." };
                return out;
            }

            routeIdVal = val(qRoute.id[1]);
            qSegments = queryExecute(
                "SELECT
                    rts.order_index,
                    sl.id AS segment_id,
                    p1.id AS start_port_id,
                    COALESCE(NULLIF(TRIM(p1.name), ''), TRIM(sl.start_port_name), '') AS start_port,
                    p2.id AS end_port_id,
                    COALESCE(NULLIF(TRIM(p2.name), ''), TRIM(sl.end_port_name), '') AS end_port,
                    sl.dist_nm,
                    sl.is_offshore,
                    sl.is_icw
                 FROM route_template_segments rts
                 INNER JOIN segment_library sl ON sl.id = rts.segment_id
                 LEFT JOIN ports p1 ON p1.id = sl.start_port_id
                 LEFT JOIN ports p2 ON p2.id = sl.end_port_id
                 WHERE rts.route_id = :rid
                 ORDER BY rts.order_index ASC, rts.id ASC",
                {
                    rid = { value=routeIdVal, cfsqltype="cf_sql_integer" }
                },
                { datasource = application.dsn }
            );

            out.DATA.ROUTE = {
                "ID"=routeIdVal,
                "CODE"=(isNull(qRoute.code[1]) ? "" : toString(qRoute.code[1])),
                "NAME"=(isNull(qRoute.name[1]) ? "" : toString(qRoute.name[1])),
                "DESCRIPTION"=(isNull(qRoute.description[1]) ? "" : toString(qRoute.description[1]))
            };

            for (i = 1; i LTE qSegments.recordCount; i++) {
                srcIdx = (directionVal EQ "CW" ? (qSegments.recordCount - i + 1) : i);
                segObj = {
                    "ORDER_INDEX"=i,
                    "SEGMENT_ID"=val(qSegments.segment_id[srcIdx]),
                    "START_PORT_ID"=(directionVal EQ "CW" ? (isNull(qSegments.end_port_id[srcIdx]) ? 0 : val(qSegments.end_port_id[srcIdx])) : (isNull(qSegments.start_port_id[srcIdx]) ? 0 : val(qSegments.start_port_id[srcIdx]))),
                    "START_PORT"=(directionVal EQ "CW" ? (isNull(qSegments.end_port[srcIdx]) ? "" : toString(qSegments.end_port[srcIdx])) : (isNull(qSegments.start_port[srcIdx]) ? "" : toString(qSegments.start_port[srcIdx]))),
                    "END_PORT_ID"=(directionVal EQ "CW" ? (isNull(qSegments.start_port_id[srcIdx]) ? 0 : val(qSegments.start_port_id[srcIdx])) : (isNull(qSegments.end_port_id[srcIdx]) ? 0 : val(qSegments.end_port_id[srcIdx]))),
                    "END_PORT"=(directionVal EQ "CW" ? (isNull(qSegments.start_port[srcIdx]) ? "" : toString(qSegments.start_port[srcIdx])) : (isNull(qSegments.end_port[srcIdx]) ? "" : toString(qSegments.end_port[srcIdx]))),
                    "DIST_NM"=(isNull(qSegments.dist_nm[srcIdx]) ? 0 : val(qSegments.dist_nm[srcIdx])),
                    "IS_OFFSHORE"=(qSegments.is_offshore[srcIdx] EQ 1),
                    "IS_ICW"=(qSegments.is_icw[srcIdx] EQ 1)
                };
                arrayAppend(out.DATA.SEGMENTS, segObj);
            }

            out.SUCCESS = true;
            out.MESSAGE = "OK";
            out.DATA.DIRECTION = directionVal;
            return out;
        </cfscript>
    </cffunction>

    <cffunction name="listCanonicalLocations" access="private" returntype="struct" output="false">
        <cfargument name="direction" type="string" required="false" default="CCW">
        <cfscript>
            var out = {
                "SUCCESS"=true,
                "AUTH"=true,
                "MESSAGE"="OK",
                "TEMPLATE_ROUTE_CODE"="GREAT_LOOP_CCW",
                "LOCATIONS"=[],
                "START_LOCATIONS"=[],
                "END_LOCATIONS"=[]
            };
            var qTpl = queryExecute(
                "SELECT id
                 FROM loop_routes
                 WHERE short_code = :code
                 LIMIT 1",
                { code = { value=out.TEMPLATE_ROUTE_CODE, cfsqltype="cf_sql_varchar" } },
                { datasource = application.dsn }
            );
            if (qTpl.recordCount EQ 0) {
                return {
                    "SUCCESS"=false,
                    "AUTH"=true,
                    "MESSAGE"="Template route not found",
                    "ERROR"={"MESSAGE"=out.TEMPLATE_ROUTE_CODE & " was not found in loop_routes"}
                };
            }

            var qNodes = queryExecute(
                "SELECT s.start_name, s.end_name
                 FROM loop_segments s
                 INNER JOIN loop_sections sec ON sec.id = s.section_id
                 WHERE sec.route_id = :rid
                 ORDER BY sec.order_index ASC, s.order_index ASC",
                { rid = { value=val(qTpl.id[1]), cfsqltype="cf_sql_integer" } },
                { datasource = application.dsn }
            );

            var seen = {};
            var seenStarts = {};
            var seenEnds = {};
            var directionVal = normalizeDirection(arguments.direction);
            var i = 0;
            var srcIdx = 0;
            var locationValue = "";
            var locationKey = "";
            var orientedStart = "";
            var orientedEnd = "";

            for (i = 1; i LTE qNodes.recordCount; i++) {
                srcIdx = (directionVal EQ "CW" ? (qNodes.recordCount - i + 1) : i);
                orientedStart = (directionVal EQ "CW" ? qNodes.end_name[srcIdx] : qNodes.start_name[srcIdx]);
                orientedEnd = (directionVal EQ "CW" ? qNodes.start_name[srcIdx] : qNodes.end_name[srcIdx]);

                locationValue = trim(toString(orientedStart));
                if (len(locationValue)) {
                    locationKey = normalizeText(locationValue);
                    if (!len(locationKey)) locationKey = lCase(locationValue);
                    if (!structKeyExists(seenStarts, locationKey)) {
                        seenStarts[locationKey] = true;
                        arrayAppend(out.START_LOCATIONS, locationValue);
                    }
                    if (!structKeyExists(seen, locationKey)) {
                        seen[locationKey] = true;
                        arrayAppend(out.LOCATIONS, locationValue);
                    }
                }

                locationValue = trim(toString(orientedEnd));
                if (len(locationValue)) {
                    locationKey = normalizeText(locationValue);
                    if (!len(locationKey)) locationKey = lCase(locationValue);
                    if (!structKeyExists(seenEnds, locationKey)) {
                        seenEnds[locationKey] = true;
                        arrayAppend(out.END_LOCATIONS, locationValue);
                    }
                    if (!structKeyExists(seen, locationKey)) {
                        seen[locationKey] = true;
                        arrayAppend(out.LOCATIONS, locationValue);
                    }
                }
            }
            out.DIRECTION = directionVal;
            return out;
        </cfscript>
    </cffunction>

    <cffunction name="getRouteTemplateDetours" access="private" returntype="struct" output="false">
        <cfargument name="routeId" type="numeric" required="false" default="0">
        <cfargument name="routeCode" type="string" required="false" default="">
        <cfscript>
            var out = {
                "SUCCESS"=false,
                "AUTH"=true,
                "MESSAGE"="Route detours unavailable",
                "DATA"={ "DETOURS"=[], "DETOUR_SEGMENTS"={} }
            };
            var routeIdVal = val(arguments.routeId);
            var routeCodeVal = trim(arguments.routeCode);
            var qRoute = queryNew("");
            var qDetours = queryNew("");
            var qDetourSegments = queryNew("");
            var i = 0;
            var detourCode = "";

            if (routeIdVal LTE 0 AND !len(routeCodeVal)) {
                out.MESSAGE = "Missing required fields";
                out.ERROR = { "MESSAGE"="routeId or routeCode is required." };
                return out;
            }

            if (routeIdVal GT 0) {
                qRoute = queryExecute(
                    "SELECT id
                     FROM loop_routes
                     WHERE id = :rid
                       AND is_active = 1
                       AND short_code NOT LIKE :userPrefix
                     LIMIT 1",
                    {
                        rid = { value=routeIdVal, cfsqltype="cf_sql_integer" },
                        userPrefix = { value="USER_ROUTE_%", cfsqltype="cf_sql_varchar" }
                    },
                    { datasource = application.dsn }
                );
            } else {
                qRoute = queryExecute(
                    "SELECT id
                     FROM loop_routes
                     WHERE is_active = 1
                       AND short_code NOT LIKE :userPrefix
                       AND (short_code = :rcode OR code = :rcode)
                     ORDER BY CASE WHEN short_code = :rcode THEN 0 ELSE 1 END, id ASC
                     LIMIT 1",
                    {
                        userPrefix = { value="USER_ROUTE_%", cfsqltype="cf_sql_varchar" },
                        rcode = { value=routeCodeVal, cfsqltype="cf_sql_varchar" }
                    },
                    { datasource = application.dsn }
                );
            }

            if (qRoute.recordCount EQ 0) {
                out.MESSAGE = "Route template not found";
                out.ERROR = { "MESSAGE"="No active canonical route template matched the provided routeId/routeCode." };
                return out;
            }
            routeIdVal = val(qRoute.id[1]);

            qDetours = queryExecute(
                "SELECT
                    d.id AS detour_id,
                    d.detour_code,
                    d.name,
                    d.description,
                    d.detour_type,
                    d.sort_order,
                    d.is_active
                 FROM route_template_detours d
                 WHERE d.route_id = :rid
                 ORDER BY d.sort_order ASC, d.id ASC",
                {
                    rid = { value=routeIdVal, cfsqltype="cf_sql_integer" }
                },
                { datasource = application.dsn }
            );

            for (i = 1; i LTE qDetours.recordCount; i++) {
                detourCode = (isNull(qDetours.detour_code[i]) ? "" : trim(toString(qDetours.detour_code[i])));
                arrayAppend(out.DATA.DETOURS, {
                    "DETOUR_ID"=val(qDetours.detour_id[i]),
                    "DETOUR_CODE"=detourCode,
                    "NAME"=(isNull(qDetours.name[i]) ? "" : toString(qDetours.name[i])),
                    "DESCRIPTION"=(isNull(qDetours.description[i]) ? "" : toString(qDetours.description[i])),
                    "DETOUR_TYPE"=(isNull(qDetours.detour_type[i]) ? "" : toString(qDetours.detour_type[i])),
                    "SORT_ORDER"=(isNull(qDetours.sort_order[i]) ? 0 : val(qDetours.sort_order[i])),
                    "IS_ACTIVE"=(qDetours.is_active[i] EQ 1)
                });
                if (len(detourCode) AND !structKeyExists(out.DATA.DETOUR_SEGMENTS, detourCode)) {
                    out.DATA.DETOUR_SEGMENTS[detourCode] = [];
                }
            }

            qDetourSegments = queryExecute(
                "SELECT
                    d.detour_code,
                    dts.order_index,
                    sl.id AS segment_id,
                    p1.id AS start_port_id,
                    COALESCE(NULLIF(TRIM(p1.name), ''), TRIM(sl.start_port_name), '') AS start_port,
                    p2.id AS end_port_id,
                    COALESCE(NULLIF(TRIM(p2.name), ''), TRIM(sl.end_port_name), '') AS end_port,
                    sl.dist_nm,
                    sl.is_offshore,
                    sl.is_icw
                 FROM route_template_detours d
                 INNER JOIN route_template_detour_segments dts ON dts.detour_id = d.id
                 INNER JOIN segment_library sl ON sl.id = dts.segment_id
                 LEFT JOIN ports p1 ON p1.id = sl.start_port_id
                 LEFT JOIN ports p2 ON p2.id = sl.end_port_id
                 WHERE d.route_id = :rid
                 ORDER BY d.sort_order ASC, d.id ASC, dts.order_index ASC, dts.id ASC",
                {
                    rid = { value=routeIdVal, cfsqltype="cf_sql_integer" }
                },
                { datasource = application.dsn }
            );

            for (i = 1; i LTE qDetourSegments.recordCount; i++) {
                detourCode = (isNull(qDetourSegments.detour_code[i]) ? "" : trim(toString(qDetourSegments.detour_code[i])));
                if (!len(detourCode)) {
                    continue;
                }
                if (!structKeyExists(out.DATA.DETOUR_SEGMENTS, detourCode)) {
                    out.DATA.DETOUR_SEGMENTS[detourCode] = [];
                }
                arrayAppend(out.DATA.DETOUR_SEGMENTS[detourCode], {
                    "ORDER_INDEX"=(isNull(qDetourSegments.order_index[i]) ? 0 : val(qDetourSegments.order_index[i])),
                    "SEGMENT_ID"=val(qDetourSegments.segment_id[i]),
                    "START_PORT_ID"=(isNull(qDetourSegments.start_port_id[i]) ? 0 : val(qDetourSegments.start_port_id[i])),
                    "START_PORT"=(isNull(qDetourSegments.start_port[i]) ? "" : toString(qDetourSegments.start_port[i])),
                    "END_PORT_ID"=(isNull(qDetourSegments.end_port_id[i]) ? 0 : val(qDetourSegments.end_port_id[i])),
                    "END_PORT"=(isNull(qDetourSegments.end_port[i]) ? "" : toString(qDetourSegments.end_port[i])),
                    "DIST_NM"=(isNull(qDetourSegments.dist_nm[i]) ? 0 : val(qDetourSegments.dist_nm[i])),
                    "IS_OFFSHORE"=(qDetourSegments.is_offshore[i] EQ 1),
                    "IS_ICW"=(qDetourSegments.is_icw[i] EQ 1)
                });
            }

            out.SUCCESS = true;
            out.MESSAGE = "OK";
            return out;
        </cfscript>
    </cffunction>

    <cffunction name="updateSegment" access="private" returntype="struct" output="false">
        <cfargument name="userId" type="numeric" required="true">
        <cfargument name="routeCode" type="string" required="true">
        <cfargument name="segmentId" type="numeric" required="true">
        <cfargument name="body" type="struct" required="true">
        <cfscript>
            var out = { "SUCCESS"=false, "AUTH"=true, "MESSAGE"="Update failed" };
            var qOwner = queryExecute(
                "SELECT s.id, sec.name AS section_name, sec.short_code AS section_short_code
                 FROM loop_segments s
                 INNER JOIN loop_sections sec ON sec.id = s.section_id
                 INNER JOIN loop_routes r ON r.id = sec.route_id
                 WHERE s.id = :sid
                   AND r.short_code = :rcode
                 LIMIT 1",
                {
                    sid = { value=arguments.segmentId, cfsqltype="cf_sql_integer" },
                    rcode = { value=arguments.routeCode, cfsqltype="cf_sql_varchar" }
                },
                { datasource = application.dsn }
            );
            if (qOwner.recordCount EQ 0) {
                return {
                    "SUCCESS"=false,
                    "AUTH"=true,
                    "MESSAGE"="Segment not found for route",
                    "ERROR"={"MESSAGE"="Segment does not belong to routeCode"}
                };
            }

            var qCurrent = queryExecute(
                "SELECT start_name, end_name, dist_nm, lock_count, rm_start, rm_end, notes
                 FROM loop_segments
                 WHERE id = :sid
                 LIMIT 1",
                { sid = { value=arguments.segmentId, cfsqltype="cf_sql_integer" } },
                { datasource = application.dsn }
            );
            if (qCurrent.recordCount EQ 0) {
                return {
                    "SUCCESS"=false,
                    "AUTH"=true,
                    "MESSAGE"="Segment not found",
                    "ERROR"={"MESSAGE"="Unable to load current segment values."}
                };
            }

            var hasStartName = structKeyExists(arguments.body, "start_name");
            var hasEndName = structKeyExists(arguments.body, "end_name");
            var hasDistNm = structKeyExists(arguments.body, "dist_nm");
            var hasLockCount = structKeyExists(arguments.body, "lock_count");
            var hasRmStart = structKeyExists(arguments.body, "rm_start");
            var hasRmEnd = structKeyExists(arguments.body, "rm_end");
            var hasNotes = structKeyExists(arguments.body, "notes");

            var startNameRaw = hasStartName ? pickStruct(arguments.body, "start_name", "") : qCurrent.start_name[1];
            var endNameRaw = hasEndName ? pickStruct(arguments.body, "end_name", "") : qCurrent.end_name[1];
            var distNmRaw = hasDistNm ? pickStruct(arguments.body, "dist_nm", "") : qCurrent.dist_nm[1];
            var lockCountRaw = hasLockCount ? pickStruct(arguments.body, "lock_count", "") : qCurrent.lock_count[1];
            var rmStartRaw = hasRmStart ? pickStruct(arguments.body, "rm_start", "") : qCurrent.rm_start[1];
            var rmEndRaw = hasRmEnd ? pickStruct(arguments.body, "rm_end", "") : qCurrent.rm_end[1];
            var notesRaw = hasNotes ? pickStruct(arguments.body, "notes", "") : qCurrent.notes[1];

            var startNameVal = trim(toString(startNameRaw));
            var endNameVal = trim(toString(endNameRaw));
            if (!len(startNameVal)) startNameVal = "Unknown Start";
            if (!len(endNameVal)) endNameVal = "Unknown End";

            var startName = { "isNull"=false, "value"=startNameVal };
            var endName = { "isNull"=false, "value"=endNameVal };
            var distNm = toNullableNumber(distNmRaw, "numeric");
            var lockCount = toNullableNumber(lockCountRaw, "integer");
            var rmStart = toNullableNumber(rmStartRaw, "numeric");
            var rmEnd = toNullableNumber(rmEndRaw, "numeric");
            var notes = toNullableString(notesRaw);
            var rmAutofilledStart = false;
            var rmAutofilledEnd = false;

            if ((hasStartName OR hasEndName) AND isObject(getMilepointService())) {
                var milepointService = getMilepointService();
                var rmResolved = milepointService.resolveSegmentRM(
                    (isNull(qOwner.section_name[1]) ? "" : qOwner.section_name[1]),
                    startName.value,
                    endName.value
                );
                if (NOT hasRmStart AND rmResolved.START_FOUND) {
                    rmStart = { "isNull"=false, "value"=rmResolved.RM_START };
                    rmAutofilledStart = true;
                }
                if (NOT hasRmEnd AND rmResolved.END_FOUND) {
                    rmEnd = { "isNull"=false, "value"=rmResolved.RM_END };
                    rmAutofilledEnd = true;
                }
                if (NOT hasRmStart AND NOT rmResolved.START_FOUND AND isNullableZero(rmStart)) {
                    rmStart = { "isNull"=true, "value"=0 };
                }
                if (NOT hasRmEnd AND NOT rmResolved.END_FOUND AND isNullableZero(rmEnd)) {
                    rmEnd = { "isNull"=true, "value"=0 };
                }
            }

            queryExecute(
                "UPDATE loop_segments
                 SET start_name = :startName,
                     end_name = :endName,
                     dist_nm = :distNm,
                     lock_count = :lockCount,
                     rm_start = :rmStart,
                     rm_end = :rmEnd,
                     notes = :notes
                 WHERE id = :sid",
                {
                    startName = { value=startName.value, cfsqltype="cf_sql_varchar", null=startName.isNull },
                    endName = { value=endName.value, cfsqltype="cf_sql_varchar", null=endName.isNull },
                    distNm = { value=distNm.value, cfsqltype="cf_sql_decimal", null=distNm.isNull },
                    lockCount = { value=lockCount.value, cfsqltype="cf_sql_integer", null=lockCount.isNull },
                    rmStart = { value=rmStart.value, cfsqltype="cf_sql_decimal", null=rmStart.isNull },
                    rmEnd = { value=rmEnd.value, cfsqltype="cf_sql_decimal", null=rmEnd.isNull },
                    notes = { value=notes.value, cfsqltype="cf_sql_varchar", null=notes.isNull },
                    sid = { value=arguments.segmentId, cfsqltype="cf_sql_integer" }
                },
                { datasource = application.dsn }
            );

            var qSeg = queryExecute(
                "SELECT id, start_name, end_name, dist_nm, lock_count, rm_start, rm_end, notes
                 FROM loop_segments
                 WHERE id = :sid
                 LIMIT 1",
                { sid = { value=arguments.segmentId, cfsqltype="cf_sql_integer" } },
                { datasource = application.dsn }
            );

            if (qSeg.recordCount EQ 1) {
                out.SUCCESS = true;
                out.MESSAGE = "Segment updated";
                out.RM_AUTOFILLED_START = rmAutofilledStart;
                out.RM_AUTOFILLED_END = rmAutofilledEnd;
                out.SEGMENT = {
                    "ID"=qSeg.id[1],
                    "START_NAME"=(isNull(qSeg.start_name[1]) ? "" : qSeg.start_name[1]),
                    "END_NAME"=(isNull(qSeg.end_name[1]) ? "" : qSeg.end_name[1]),
                    "DIST_NM"=(isNull(qSeg.dist_nm[1]) ? "" : val(qSeg.dist_nm[1])),
                    "LOCK_COUNT"=(isNull(qSeg.lock_count[1]) ? "" : val(qSeg.lock_count[1])),
                    "RM_START"=(isNull(qSeg.rm_start[1]) ? "" : val(qSeg.rm_start[1])),
                    "RM_END"=(isNull(qSeg.rm_end[1]) ? "" : val(qSeg.rm_end[1])),
                    "NOTES"=(isNull(qSeg.notes[1]) ? "" : qSeg.notes[1])
                };
            }
            return out;
        </cfscript>
    </cffunction>

    <cffunction name="listUserRoutes" access="private" returntype="struct" output="false">
        <cfargument name="userId" type="numeric" required="true">
        <cfscript>
            var out = { "SUCCESS"=true, "AUTH"=true, "MESSAGE"="OK", "ROUTES"=[], "ACTIVE_ROUTE_CODE"="" };
            var routePrefix = "USER_ROUTE_" & int(arguments.userId) & "_%";
            var qRoutes = queryExecute(
                "SELECT id, name, short_code, description
                 FROM loop_routes
                 WHERE short_code LIKE :prefix
                 ORDER BY id DESC",
                { prefix = { value=routePrefix, cfsqltype="cf_sql_varchar" } },
                { datasource = application.dsn }
            );
            var i = 0;
            var timeline = {};
            for (i = 1; i LTE qRoutes.recordCount; i++) {
                timeline = getTimeline(arguments.userId, qRoutes.short_code[i]);
                if (!structKeyExists(timeline, "SUCCESS") OR timeline.SUCCESS EQ false) {
                    continue;
                }
                arrayAppend(out.ROUTES, {
                    "ID"=qRoutes.id[i],
                    "NAME"=(isNull(qRoutes.name[i]) ? "" : qRoutes.name[i]),
                    "SHORT_CODE"=qRoutes.short_code[i],
                    "DESCRIPTION"=(isNull(qRoutes.description[i]) ? "" : qRoutes.description[i]),
                    "TOTALS"=timeline.TOTALS
                });
            }

            if (structKeyExists(session, "expeditionRouteCode")) {
                out.ACTIVE_ROUTE_CODE = toString(session.expeditionRouteCode);
            }
            var hasActive = false;
            for (i = 1; i LTE arrayLen(out.ROUTES); i++) {
                if (out.ROUTES[i].SHORT_CODE EQ out.ACTIVE_ROUTE_CODE) {
                    hasActive = true;
                    break;
                }
            }
            if (!hasActive) {
                out.ACTIVE_ROUTE_CODE = "";
            }
            if (!len(out.ACTIVE_ROUTE_CODE) AND arrayLen(out.ROUTES)) {
                out.ACTIVE_ROUTE_CODE = out.ROUTES[1].SHORT_CODE;
                session.expeditionRouteCode = out.ACTIVE_ROUTE_CODE;
            }
            return out;
        </cfscript>
    </cffunction>

    <cffunction name="buildFloatPlansFromRoute" access="private" returntype="struct" output="false">
        <cfargument name="userId" type="numeric" required="true">
        <cfargument name="routeInstanceId" type="numeric" required="false" default="0">
        <cfargument name="routeCode" type="string" required="false" default="">
        <cfargument name="mode" type="string" required="false" default="DAILY">
        <cfargument name="vesselId" type="numeric" required="false" default="0">
        <cfargument name="rebuild" type="any" required="false" default="false">
        <cfscript>
            var out = {
                "SUCCESS"=false,
                "AUTH"=true,
                "MESSAGE"="Unable to build float plans from route.",
                "ROUTE_INSTANCE_ID"=0,
                "ROUTE_CODE"="",
                "MODE"="DAILY",
                "CREATED_COUNT"=0,
                "FLOATPLAN_IDS"=[],
                "FLOATPLANS"=[]
            };

            var routeCodeVal = trim(arguments.routeCode);
            var routeInstanceIdVal = val(arguments.routeInstanceId);
            var modeVal = normalizeBuildMode(arguments.mode);
            var rebuildVal = toBoolean(arguments.rebuild, false);
            var userIdText = toString(arguments.userId);
            var vesselIdVal = val(arguments.vesselId);
            var qRouteInstance = queryNew("");
            var qPreferredVessel = queryNew("");
            var generatedRouteId = 0;
            var qRoute = queryNew("");
            var qSegments = queryNew("");
            var existingCount = 0;
            var activeExistingCount = 0;
            var dayRows = [];
            var sectionOrder = [];
            var sectionMap = {};
            var sid = "";
            var secObj = {};
            var i = 0;
            var totalNm = 0.0;
            var totalLocks = 0;
            var dayNum = 0;
            var dayObj = {};
            var planName = "";
            var notesVal = "";
            var newPlanId = 0;

            if (routeInstanceIdVal LTE 0 AND !len(routeCodeVal)) {
                out.MESSAGE = "Missing required fields";
                out.ERROR = { "CODE"="MISSING_ROUTE_REFERENCE", "MESSAGE"="routeInstanceId or routeCode is required." };
                return out;
            }

            if (routeInstanceIdVal GT 0) {
                qRouteInstance = queryExecute(
                    "SELECT id, generated_route_id, generated_route_code
                     FROM route_instances
                     WHERE id = :rid
                       AND user_id = :uid
                     LIMIT 1",
                    {
                        rid = { value=routeInstanceIdVal, cfsqltype="cf_sql_integer" },
                        uid = { value=userIdText, cfsqltype="cf_sql_varchar" }
                    },
                    { datasource = application.dsn }
                );
            } else {
                qRouteInstance = queryExecute(
                    "SELECT id, generated_route_id, generated_route_code
                     FROM route_instances
                     WHERE generated_route_code = :rcode
                       AND user_id = :uid
                     ORDER BY id DESC
                     LIMIT 1",
                    {
                        rcode = { value=routeCodeVal, cfsqltype="cf_sql_varchar" },
                        uid = { value=userIdText, cfsqltype="cf_sql_varchar" }
                    },
                    { datasource = application.dsn }
                );
            }

            if (qRouteInstance.recordCount EQ 0) {
                out.MESSAGE = "Route instance not found";
                out.ERROR = { "CODE"="ROUTE_INSTANCE_NOT_FOUND", "MESSAGE"="No route instance found for the selected route." };
                return out;
            }

            routeInstanceIdVal = val(qRouteInstance.id[1]);
            generatedRouteId = val(qRouteInstance.generated_route_id[1]);
            if (!len(routeCodeVal)) {
                routeCodeVal = trim(toString(qRouteInstance.generated_route_code[1]));
            }

            out.ROUTE_INSTANCE_ID = routeInstanceIdVal;
            out.ROUTE_CODE = routeCodeVal;
            out.MODE = modeVal;

            if (generatedRouteId LTE 0) {
                out.MESSAGE = "Route instance is missing generated route linkage";
                out.ERROR = { "CODE"="MISSING_GENERATED_ROUTE", "MESSAGE"="Route instance does not have a generated route id." };
                return out;
            }

            if (vesselIdVal LTE 0) {
                qPreferredVessel = queryExecute(
                    "SELECT vesselID
                     FROM vessels
                     WHERE userId = :uid
                     ORDER BY vesselID ASC
                     LIMIT 1",
                    { uid = { value=userIdText, cfsqltype="cf_sql_varchar" } },
                    { datasource = application.dsn }
                );
                if (qPreferredVessel.recordCount EQ 0) {
                    out.MESSAGE = "No vessel available";
                    out.ERROR = { "CODE"="NO_VESSEL", "MESSAGE"="A vessel is required before building float plans." };
                    return out;
                }
                vesselIdVal = val(qPreferredVessel.vesselID[1]);
            }

            qRoute = queryExecute(
                "SELECT id, name, short_code
                 FROM loop_routes
                 WHERE id = :rid
                 LIMIT 1",
                { rid = { value=generatedRouteId, cfsqltype="cf_sql_integer" } },
                { datasource = application.dsn }
            );
            if (qRoute.recordCount EQ 0) {
                out.MESSAGE = "Generated route not found";
                out.ERROR = { "CODE"="GENERATED_ROUTE_NOT_FOUND", "MESSAGE"="The generated route for this instance no longer exists." };
                return out;
            }

            qSegments = queryExecute(
                "SELECT sec.id AS section_id, sec.name AS section_name, sec.order_index AS section_order,
                        s.id AS segment_id, s.order_index AS segment_order, s.start_name, s.end_name, s.dist_nm, s.lock_count
                 FROM loop_sections sec
                 INNER JOIN loop_segments s ON s.section_id = sec.id
                 WHERE sec.route_id = :rid
                 ORDER BY sec.order_index ASC, s.order_index ASC",
                { rid = { value=generatedRouteId, cfsqltype="cf_sql_integer" } },
                { datasource = application.dsn }
            );
            if (qSegments.recordCount EQ 0) {
                out.MESSAGE = "Generated route has no segments";
                out.ERROR = { "CODE"="EMPTY_ROUTE", "MESSAGE"="Cannot build float plans from an empty route." };
                return out;
            }

            for (i = 1; i LTE qSegments.recordCount; i++) {
                sid = toString(qSegments.section_id[i]);
                if (!structKeyExists(sectionMap, sid)) {
                    secObj = {
                        "SECTION_ID"=qSegments.section_id[i],
                        "SECTION_NAME"=(isNull(qSegments.section_name[i]) ? "Section" : qSegments.section_name[i]),
                        "SECTION_ORDER"=val(qSegments.section_order[i]),
                        "START_NAME"=(isNull(qSegments.start_name[i]) ? "" : trim(toString(qSegments.start_name[i]))),
                        "END_NAME"=(isNull(qSegments.end_name[i]) ? "" : trim(toString(qSegments.end_name[i]))),
                        "TOTAL_NM"=0.0,
                        "TOTAL_LOCKS"=0,
                        "SEGMENT_COUNT"=0
                    };
                    sectionMap[sid] = secObj;
                    arrayAppend(sectionOrder, sid);
                }
                if (len(trim(toString(qSegments.end_name[i])))) {
                    sectionMap[sid].END_NAME = trim(toString(qSegments.end_name[i]));
                }
                sectionMap[sid].TOTAL_NM = sectionMap[sid].TOTAL_NM + val(qSegments.dist_nm[i]);
                sectionMap[sid].TOTAL_LOCKS = sectionMap[sid].TOTAL_LOCKS + val(qSegments.lock_count[i]);
                sectionMap[sid].SEGMENT_COUNT = sectionMap[sid].SEGMENT_COUNT + 1;
                totalNm = totalNm + val(qSegments.dist_nm[i]);
                totalLocks = totalLocks + val(qSegments.lock_count[i]);
            }

            if (modeVal EQ "SINGLE_MASTER") {
                dayObj = {
                    "DAY_NUMBER"=1,
                    "LABEL"="Day 1 - Full Route",
                    "START_NAME"=(isNull(qSegments.start_name[1]) ? "" : trim(toString(qSegments.start_name[1]))),
                    "END_NAME"=(isNull(qSegments.end_name[qSegments.recordCount]) ? "" : trim(toString(qSegments.end_name[qSegments.recordCount]))),
                    "TOTAL_NM"=roundTo2(totalNm),
                    "TOTAL_LOCKS"=totalLocks,
                    "SEGMENT_COUNT"=qSegments.recordCount
                };
                if (!len(dayObj.START_NAME)) dayObj.START_NAME = "Unknown Start";
                if (!len(dayObj.END_NAME)) dayObj.END_NAME = "Unknown End";
                arrayAppend(dayRows, dayObj);
            } else {
                dayNum = 0;
                for (i = 1; i LTE arrayLen(sectionOrder); i++) {
                    secObj = sectionMap[sectionOrder[i]];
                    if (secObj.SEGMENT_COUNT LTE 0) continue;
                    dayNum += 1;
                    dayObj = {
                        "DAY_NUMBER"=dayNum,
                        "LABEL"=("Day " & dayNum & " - " & secObj.SECTION_NAME),
                        "START_NAME"=(len(secObj.START_NAME) ? secObj.START_NAME : "Unknown Start"),
                        "END_NAME"=(len(secObj.END_NAME) ? secObj.END_NAME : "Unknown End"),
                        "TOTAL_NM"=roundTo2(secObj.TOTAL_NM),
                        "TOTAL_LOCKS"=secObj.TOTAL_LOCKS,
                        "SEGMENT_COUNT"=secObj.SEGMENT_COUNT
                    };
                    arrayAppend(dayRows, dayObj);
                }
            }

            if (!arrayLen(dayRows)) {
                out.MESSAGE = "No route days to build";
                out.ERROR = { "CODE"="NO_DAYS", "MESSAGE"="Could not derive any float plan days from route segments." };
                return out;
            }

            var qExisting = queryExecute(
                "SELECT floatPlanId, status
                 FROM floatplans
                 WHERE userId = :uid
                   AND route_instance_id = :routeInstanceId
                 ORDER BY floatPlanId DESC",
                {
                    uid = { value=userIdText, cfsqltype="cf_sql_varchar" },
                    routeInstanceId = { value=routeInstanceIdVal, cfsqltype="cf_sql_integer" }
                },
                { datasource = application.dsn }
            );
            existingCount = qExisting.recordCount;

            if (existingCount GT 0 AND NOT rebuildVal) {
                out.MESSAGE = "Float plans already exist for this route instance.";
                out.ERROR = {
                    "CODE"="FLOATPLANS_ALREADY_EXIST",
                    "MESSAGE"="Float plans already exist. Re-run with rebuild=true to replace draft/closed plans."
                };
                out.EXISTING_COUNT = existingCount;
                return out;
            }

            if (existingCount GT 0 AND rebuildVal) {
                activeExistingCount = 0;
                for (i = 1; i LTE qExisting.recordCount; i++) {
                    if (listFindNoCase("DRAFT,CLOSED,COMPLETED,CANCELLED,CANCELED", trim(toString(qExisting.status[i]))) EQ 0) {
                        activeExistingCount += 1;
                    }
                }
                if (activeExistingCount GT 0) {
                    out.MESSAGE = "Cannot rebuild while active route-linked float plans exist.";
                    out.ERROR = {
                        "CODE"="FLOATPLANS_REBUILD_BLOCKED",
                        "MESSAGE"="Only draft/closed/completed/cancelled route-linked float plans may be replaced."
                    };
                    out.ACTIVE_EXISTING_COUNT = activeExistingCount;
                    return out;
                }
            }

            transaction {
                if (existingCount GT 0 AND rebuildVal) {
                    queryExecute(
                        "DELETE FROM floatplans
                         WHERE userId = :uid
                           AND route_instance_id = :routeInstanceId",
                        {
                            uid = { value=userIdText, cfsqltype="cf_sql_varchar" },
                            routeInstanceId = { value=routeInstanceIdVal, cfsqltype="cf_sql_integer" }
                        },
                        { datasource = application.dsn }
                    );
                }

                for (i = 1; i LTE arrayLen(dayRows); i++) {
                    dayObj = dayRows[i];
                    planName = trim(toString(qRoute.name[1])) & " - " & dayObj.LABEL;
                    notesVal = "Auto-generated from route " & routeCodeVal & " (" & modeVal & "). "
                        & dayObj.START_NAME & " to " & dayObj.END_NAME & ". "
                        & dayObj.TOTAL_NM & " NM, " & dayObj.TOTAL_LOCKS & " locks.";

                    queryExecute(
                        "INSERT INTO floatplans
                            (userId, floatPlanName, vesselId, departing, returning, notes, route_instance_id, route_day_number, status, dateCreated, lastUpdate)
                         VALUES
                            (:userId, :planName, :vesselId, :departing, :returning, :notes, :routeInstanceId, :routeDayNumber, 'Draft', NOW(), NOW())",
                        {
                            userId = { value=userIdText, cfsqltype="cf_sql_varchar" },
                            planName = { value=planName, cfsqltype="cf_sql_varchar" },
                            vesselId = { value=vesselIdVal, cfsqltype="cf_sql_integer", null=(vesselIdVal LTE 0) },
                            departing = { value=dayObj.START_NAME, cfsqltype="cf_sql_varchar", null=NOT len(dayObj.START_NAME) },
                            returning = { value=dayObj.END_NAME, cfsqltype="cf_sql_varchar", null=NOT len(dayObj.END_NAME) },
                            notes = { value=notesVal, cfsqltype="cf_sql_varchar", null=NOT len(notesVal) },
                            routeInstanceId = { value=routeInstanceIdVal, cfsqltype="cf_sql_integer" },
                            routeDayNumber = { value=dayObj.DAY_NUMBER, cfsqltype="cf_sql_integer" }
                        },
                        { datasource = application.dsn, result = "fpInsert" }
                    );
                    newPlanId = val(fpInsert.generatedKey);
                    arrayAppend(out.FLOATPLAN_IDS, newPlanId);
                    arrayAppend(out.FLOATPLANS, {
                        "FLOATPLAN_ID"=newPlanId,
                        "ROUTE_DAY_NUMBER"=dayObj.DAY_NUMBER,
                        "LABEL"=dayObj.LABEL,
                        "START_NAME"=dayObj.START_NAME,
                        "END_NAME"=dayObj.END_NAME,
                        "TOTAL_NM"=dayObj.TOTAL_NM,
                        "TOTAL_LOCKS"=dayObj.TOTAL_LOCKS
                    });
                }
            }

            out.SUCCESS = true;
            out.CREATED_COUNT = arrayLen(out.FLOATPLAN_IDS);
            if (existingCount GT 0 AND rebuildVal) {
                out.MESSAGE = "Rebuilt " & out.CREATED_COUNT & " float plans from route.";
                out.REBUILT = true;
                out.REMOVED_EXISTING_COUNT = existingCount;
            } else {
                out.MESSAGE = "Built " & out.CREATED_COUNT & " float plans from route.";
                out.REBUILT = false;
            }
            return out;
        </cfscript>
    </cffunction>

    <cffunction name="setActiveRoute" access="private" returntype="struct" output="false">
        <cfargument name="userId" type="numeric" required="true">
        <cfargument name="routeCode" type="string" required="true">
        <cfscript>
            var code = trim(arguments.routeCode);
            if (!isUserOwnedRoute(arguments.userId, code)) {
                return {
                    "SUCCESS"=false,
                    "AUTH"=true,
                    "MESSAGE"="Route not found",
                    "ERROR"={"MESSAGE"="Route is not available for this user."}
                };
            }
            session.expeditionRouteCode = code;
            return { "SUCCESS"=true, "AUTH"=true, "MESSAGE"="OK", "ACTIVE_ROUTE_CODE"=code };
        </cfscript>
    </cffunction>

    <cffunction name="isUserOwnedRoute" access="private" returntype="boolean" output="false">
        <cfargument name="userId" type="numeric" required="true">
        <cfargument name="routeCode" type="string" required="true">
        <cfscript>
            var prefix = "USER_ROUTE_" & int(arguments.userId) & "_%";
            var q = queryExecute(
                "SELECT id
                 FROM loop_routes
                 WHERE short_code = :code
                   AND short_code LIKE :prefix
                 LIMIT 1",
                {
                    code = { value=arguments.routeCode, cfsqltype="cf_sql_varchar" },
                    prefix = { value=prefix, cfsqltype="cf_sql_varchar" }
                },
                { datasource = application.dsn }
            );
            return q.recordCount GT 0;
        </cfscript>
    </cffunction>

    <cffunction name="deleteRoute" access="private" returntype="struct" output="false">
        <cfargument name="userId" type="numeric" required="true">
        <cfargument name="routeCode" type="string" required="true">
        <cfscript>
            var code = trim(arguments.routeCode);
            if (!isUserOwnedRoute(arguments.userId, code)) {
                return {
                    "SUCCESS"=false,
                    "AUTH"=true,
                    "MESSAGE"="Route not found",
                    "ERROR"={"MESSAGE"="Route is not available for this user."}
                };
            }

            var qRoute = queryExecute(
                "SELECT id
                 FROM loop_routes
                 WHERE short_code = :code
                 LIMIT 1",
                { code = { value=code, cfsqltype="cf_sql_varchar" } },
                { datasource = application.dsn }
            );
            if (qRoute.recordCount EQ 0) {
                return {
                    "SUCCESS"=false,
                    "AUTH"=true,
                    "MESSAGE"="Route not found",
                    "ERROR"={"MESSAGE"="Route does not exist."}
                };
            }

            var routeId = val(qRoute.id[1]);
            transaction {
                queryExecute(
                    "DELETE FROM user_route_progress
                     WHERE segment_id IN (
                        SELECT s.id
                        FROM loop_segments s
                        INNER JOIN loop_sections sec ON sec.id = s.section_id
                        WHERE sec.route_id = :rid
                     )",
                    { rid = { value=routeId, cfsqltype="cf_sql_integer" } },
                    { datasource = application.dsn }
                );
                queryExecute(
                    "DELETE FROM loop_segments
                     WHERE section_id IN (
                        SELECT id FROM loop_sections WHERE route_id = :rid
                     )",
                    { rid = { value=routeId, cfsqltype="cf_sql_integer" } },
                    { datasource = application.dsn }
                );
                queryExecute(
                    "DELETE FROM loop_sections
                     WHERE route_id = :rid",
                    { rid = { value=routeId, cfsqltype="cf_sql_integer" } },
                    { datasource = application.dsn }
                );
                queryExecute(
                    "DELETE FROM loop_routes
                     WHERE id = :rid",
                    { rid = { value=routeId, cfsqltype="cf_sql_integer" } },
                    { datasource = application.dsn }
                );
            }

            if (structKeyExists(session, "expeditionRouteCode") AND toString(session.expeditionRouteCode) EQ code) {
                structDelete(session, "expeditionRouteCode");
            }
            return { "SUCCESS"=true, "AUTH"=true, "MESSAGE"="Route deleted", "ROUTE_CODE"=code };
        </cfscript>
    </cffunction>

    <cffunction name="getTimeline" access="private" returntype="struct" output="false">
        <cfargument name="userId" type="numeric" required="true">
        <cfargument name="routeCode" type="string" required="true">
        <cfset var resp = {
            "SUCCESS"=true,
            "AUTH"=true,
            "MESSAGE"="OK",
            "ROUTE"={},
            "TOTALS"={},
            "SECTIONS"=[]
        } />

        <cfset var qRoute = queryExecute(
            "SELECT id, name, short_code, description, is_default
             FROM loop_routes
             WHERE short_code = :code
             LIMIT 1",
            { code = { value=arguments.routeCode, cfsqltype="cf_sql_varchar" } },
            { datasource = application.dsn }
        ) />
        <cfif qRoute.recordCount EQ 0>
            <cfset resp.SUCCESS = false />
            <cfset resp.MESSAGE = "Route not found" />
            <cfset resp.ERROR = { "MESSAGE"="No loop_routes row for short_code=" & arguments.routeCode } />
            <cfreturn resp />
        </cfif>

        <cfset var routeId = qRoute.id[1] />
        <cfset resp.ROUTE = {
            "ID"=routeId,
            "NAME"=qRoute.name[1],
            "SHORT_CODE"=qRoute.short_code[1],
            "DESCRIPTION"=qRoute.description[1],
            "IS_DEFAULT"=(qRoute.is_default[1] EQ 1)
        } />

        <cfset var qSections = queryExecute(
            "SELECT id, name, short_code, phase_num, order_index, is_active_default
             FROM loop_sections
             WHERE route_id = :rid
             ORDER BY order_index ASC",
            { rid = { value=routeId, cfsqltype="cf_sql_integer" } },
            { datasource = application.dsn }
        ) />

        <cfset var qSegments = queryExecute(
            "SELECT s.id, s.section_id, s.order_index, s.start_name, s.end_name, s.dist_nm, s.lock_count,
                    s.rm_start, s.rm_end, s.is_signature_event, s.is_milestone_end, s.notes,
                    sec.order_index AS section_order
             FROM loop_segments s
             INNER JOIN loop_sections sec ON sec.id = s.section_id
             WHERE sec.route_id = :rid
             ORDER BY sec.order_index ASC, s.order_index ASC",
            { rid = { value=routeId, cfsqltype="cf_sql_integer" } },
            { datasource = application.dsn }
        ) />

        <cfset var qProg = queryExecute(
            "SELECT segment_id, status, completed_at
             FROM user_route_progress
             WHERE user_id = :uid
               AND segment_id IN (
                 SELECT s.id
                 FROM loop_segments s
                 JOIN loop_sections sec ON sec.id = s.section_id
                 WHERE sec.route_id = :rid
               )",
            {
                uid = { value=arguments.userId, cfsqltype="cf_sql_integer" },
                rid = { value=routeId, cfsqltype="cf_sql_integer" }
            },
            { datasource = application.dsn }
        ) />

        <cfset var progressBySeg = {} />
        <cfloop query="qProg">
            <cfset progressBySeg[toString(qProg.segment_id)] = {
                "STATUS"=qProg.status,
                "COMPLETED_AT"=(isNull(qProg.completed_at) ? "" : dateTimeFormat(qProg.completed_at, "yyyy-mm-dd HH:nn:ss"))
            } />
        </cfloop>

        <cfset var sections = [] />
        <cfset var sectionIndexById = {} />
        <cfset var totalNm = 0.0 />
        <cfset var totalLocks = 0 />
        <cfset var completedNm = 0.0 />
        <cfset var completedLocks = 0 />

        <cfset var i = 0 />
        <cfloop query="qSections">
            <cfset var secObj = {
                "ID"=qSections.id,
                "NAME"=qSections.name,
                "SHORT_CODE"=qSections.short_code,
                "PHASE_NUM"=qSections.phase_num,
                "ORDER_INDEX"=qSections.order_index,
                "IS_ACTIVE_DEFAULT"=(qSections.is_active_default EQ 1),
                "TOTALS"={
                    "NM"=0.0,
                    "LOCKS"=0,
                    "COMPLETED_NM"=0.0,
                    "COMPLETED_LOCKS"=0,
                    "PCT_COMPLETE"=0
                },
                "SEGMENTS"=[]
            } />
            <cfset arrayAppend(sections, secObj) />
            <cfset sectionIndexById[toString(qSections.id)] = arrayLen(sections) />
        </cfloop>

        <cfloop query="qSegments">
            <cfset var sid = toString(qSegments.section_id) />
            <cfif NOT structKeyExists(sectionIndexById, sid)>
                <cfcontinue />
            </cfif>
            <cfset var idx = sectionIndexById[sid] />
            <cfset var segIdStr = toString(qSegments.id) />
            <cfset var prog = (structKeyExists(progressBySeg, segIdStr) ? progressBySeg[segIdStr] : {"STATUS"="NOT_STARTED","COMPLETED_AT"=""}) />
            <cfset var isCompleted = (uCase(prog.STATUS) EQ "COMPLETED") />

            <cfset var segObj = {
                "ID"=qSegments.id,
                "ORDER_INDEX"=qSegments.order_index,
                "START_NAME"=(isNull(qSegments.start_name) ? "" : qSegments.start_name),
                "END_NAME"=(isNull(qSegments.end_name) ? "" : qSegments.end_name),
                "DIST_NM"=val(qSegments.dist_nm),
                "LOCK_COUNT"=val(qSegments.lock_count),
                "RM_START"=(isNull(qSegments.rm_start) ? "" : val(qSegments.rm_start)),
                "RM_END"=(isNull(qSegments.rm_end) ? "" : val(qSegments.rm_end)),
                "IS_SIGNATURE_EVENT"=(qSegments.is_signature_event EQ 1),
                "IS_MILESTONE_END"=(qSegments.is_milestone_end EQ 1),
                "NOTES"=(isNull(qSegments.notes) ? "" : qSegments.notes),
                "PROGRESS"=prog
            } />
            <cfset arrayAppend(sections[idx].SEGMENTS, segObj) />

            <cfset totalNm = totalNm + val(qSegments.dist_nm) />
            <cfset totalLocks = totalLocks + val(qSegments.lock_count) />
            <cfset sections[idx].TOTALS.NM = sections[idx].TOTALS.NM + val(qSegments.dist_nm) />
            <cfset sections[idx].TOTALS.LOCKS = sections[idx].TOTALS.LOCKS + val(qSegments.lock_count) />

            <cfif isCompleted>
                <cfset completedNm = completedNm + val(qSegments.dist_nm) />
                <cfset completedLocks = completedLocks + val(qSegments.lock_count) />
                <cfset sections[idx].TOTALS.COMPLETED_NM = sections[idx].TOTALS.COMPLETED_NM + val(qSegments.dist_nm) />
                <cfset sections[idx].TOTALS.COMPLETED_LOCKS = sections[idx].TOTALS.COMPLETED_LOCKS + val(qSegments.lock_count) />
            </cfif>
        </cfloop>

        <cfset var filteredSections = [] />
        <cfloop from="1" to="#arrayLen(sections)#" index="i">
            <cfif sections[i].TOTALS.NM GT 0>
                <cfset sections[i].TOTALS.PCT_COMPLETE = round((sections[i].TOTALS.COMPLETED_NM / sections[i].TOTALS.NM) * 100) />
            <cfelse>
                <cfset sections[i].TOTALS.PCT_COMPLETE = 0 />
            </cfif>
            <cfif arrayLen(sections[i].SEGMENTS) GT 0>
                <cfset arrayAppend(filteredSections, sections[i]) />
            </cfif>
        </cfloop>

        <cfif arrayLen(filteredSections) GT 0>
            <cfset var hasDefaultSection = false />
            <cfloop from="1" to="#arrayLen(filteredSections)#" index="i">
                <cfif filteredSections[i].IS_ACTIVE_DEFAULT>
                    <cfset hasDefaultSection = true />
                    <cfbreak />
                </cfif>
            </cfloop>
            <cfif NOT hasDefaultSection>
                <cfset filteredSections[1].IS_ACTIVE_DEFAULT = true />
            </cfif>
        </cfif>

        <cfset resp.TOTALS = {
            "TOTAL_NM"=roundTo2(totalNm),
            "TOTAL_LOCKS"=totalLocks,
            "COMPLETED_NM"=roundTo2(completedNm),
            "COMPLETED_LOCKS"=completedLocks,
            "PCT_COMPLETE"=(totalNm GT 0 ? round((completedNm/totalNm)*100) : 0)
        } />
        <cfset resp.SECTIONS = filteredSections />
        <cfreturn resp />
    </cffunction>

    <cffunction name="findFocusSegments" access="private" returntype="struct" output="false">
        <cfargument name="templateRouteId" type="numeric" required="true">
        <cfargument name="startLocation" type="string" required="true">
        <cfargument name="endLocation" type="string" required="true">
        <cfargument name="direction" type="string" required="false" default="CCW">
        <cfscript>
            var out = {
                "START_SEGMENT_ID"=0,
                "END_SEGMENT_ID"=0,
                "START_ORDER"=0,
                "END_ORDER"=0,
                "START_FOUND"=false,
                "END_FOUND"=false
            };
            var sNorm = normalizeText(arguments.startLocation);
            var eNorm = normalizeText(arguments.endLocation);
            var directionVal = normalizeDirection(arguments.direction);
            if (!len(sNorm) OR !len(eNorm)) {
                return out;
            }

            var q = queryExecute(
                "SELECT s.id, s.start_name, s.end_name, sec.order_index AS section_order, s.order_index AS seg_order
                 FROM loop_segments s
                 INNER JOIN loop_sections sec ON sec.id = s.section_id
                 WHERE sec.route_id = :rid
                 ORDER BY sec.order_index ASC, s.order_index ASC",
                { rid = { value=arguments.templateRouteId, cfsqltype="cf_sql_integer" } },
                { datasource = application.dsn }
            );

            var i = 0;
            var sScore = 0;
            var eScore = 0;
            var sBest = 0;
            var eBest = 0;
            var segStart = "";
            var segEnd = "";
            var routeOrder = 0;
            var candidateOrder = 0;
            var candidateSegId = 0;
            var candidateStartValid = false;
            var candidateEndValid = false;
            var srcIdx = 0;
            for (i = 1; i LTE q.recordCount; i++) {
                srcIdx = (directionVal EQ "CW" ? (q.recordCount - i + 1) : i);
                segStart = normalizeText(directionVal EQ "CW" ? q.end_name[srcIdx] : q.start_name[srcIdx]);
                segEnd = normalizeText(directionVal EQ "CW" ? q.start_name[srcIdx] : q.end_name[srcIdx]);
                routeOrder = i;

                sScore = 0;
                candidateStartValid = false;
                candidateSegId = 0;
                candidateOrder = 0;
                if (len(sNorm)) {
                    if (sNorm EQ segStart) {
                        sScore = 300;
                        candidateSegId = q.id[srcIdx];
                        candidateOrder = routeOrder;
                        candidateStartValid = true;
                    } else if (
                        len(segStart) AND (findNoCase(sNorm, segStart) GT 0 OR findNoCase(segStart, sNorm) GT 0)
                    ) {
                        sScore = 120;
                        candidateSegId = q.id[srcIdx];
                        candidateOrder = routeOrder;
                        candidateStartValid = true;
                    }
                }
                if (
                    candidateStartValid
                    AND
                    (
                        sScore GT sBest
                        OR
                        (sScore EQ sBest AND sBest GT 0 AND (out.START_ORDER EQ 0 OR candidateOrder LT out.START_ORDER))
                    )
                ) {
                    sBest = sScore;
                    out.START_SEGMENT_ID = candidateSegId;
                    out.START_ORDER = candidateOrder;
                    out.START_FOUND = true;
                }

                eScore = 0;
                candidateEndValid = false;
                candidateSegId = 0;
                candidateOrder = 0;
                if (len(eNorm)) {
                    if (eNorm EQ segEnd) {
                        eScore = 300;
                        candidateSegId = q.id[srcIdx];
                        candidateOrder = routeOrder;
                        candidateEndValid = true;
                    } else if (
                        len(segEnd) AND (findNoCase(eNorm, segEnd) GT 0 OR findNoCase(segEnd, eNorm) GT 0)
                    ) {
                        eScore = 120;
                        candidateSegId = q.id[srcIdx];
                        candidateOrder = routeOrder;
                        candidateEndValid = true;
                    }
                }
                if (
                    candidateEndValid
                    AND
                    (
                        eScore GT eBest
                        OR
                        (eScore EQ eBest AND eBest GT 0 AND (out.END_ORDER EQ 0 OR candidateOrder LT out.END_ORDER))
                    )
                ) {
                    eBest = eScore;
                    out.END_SEGMENT_ID = candidateSegId;
                    out.END_ORDER = candidateOrder;
                    out.END_FOUND = true;
                }
            }
            if (sBest LTE 0) out.START_FOUND = false;
            if (eBest LTE 0) out.END_FOUND = false;
            return out;
        </cfscript>
    </cffunction>

    <cffunction name="scoreNodeMatch" access="private" returntype="numeric" output="false">
        <cfargument name="needle" type="string" required="true">
        <cfargument name="nodeA" type="string" required="true">
        <cfargument name="nodeB" type="string" required="true">
        <cfscript>
            if (!len(arguments.needle)) return 0;
            if (arguments.needle EQ arguments.nodeA OR arguments.needle EQ arguments.nodeB) return 100;
            if (
                (len(arguments.nodeA) AND (findNoCase(arguments.needle, arguments.nodeA) GT 0 OR findNoCase(arguments.nodeA, arguments.needle) GT 0))
                OR
                (len(arguments.nodeB) AND (findNoCase(arguments.needle, arguments.nodeB) GT 0 OR findNoCase(arguments.nodeB, arguments.needle) GT 0))
            ) {
                return 80;
            }
            return 0;
        </cfscript>
    </cffunction>

    <cffunction name="findRouteContinuityIssue" access="private" returntype="struct" output="false">
        <cfargument name="segmentRows" type="array" required="true">
        <cfscript>
            var out = {
                "HAS_BREAK"=false,
                "NEXT_ROUTE_ORDER"=0,
                "PREV_END_RAW"="",
                "NEXT_START_RAW"=""
            };
            var i = 0;
            var prevEndRaw = "";
            var nextStartRaw = "";
            var prevEndNorm = "";
            var nextStartNorm = "";
            for (i = 2; i LTE arrayLen(arguments.segmentRows); i++) {
                prevEndRaw = trim(toString(arguments.segmentRows[i - 1].END_NAME));
                nextStartRaw = trim(toString(arguments.segmentRows[i].START_NAME));
                prevEndNorm = normalizeText(prevEndRaw);
                nextStartNorm = normalizeText(nextStartRaw);
                if (!len(prevEndNorm) OR !len(nextStartNorm)) {
                    out.HAS_BREAK = true;
                } else if (
                    areLocationNamesEquivalent(prevEndRaw, nextStartRaw)
                ) {
                    continue;
                } else {
                    out.HAS_BREAK = true;
                }
                if (out.HAS_BREAK) {
                    out.NEXT_ROUTE_ORDER = val(arguments.segmentRows[i].ROUTE_ORDER);
                    out.PREV_END_RAW = prevEndRaw;
                    out.NEXT_START_RAW = nextStartRaw;
                    return out;
                }
            }
            return out;
        </cfscript>
    </cffunction>

    <cffunction name="pickBestFullLoopSelection" access="private" returntype="struct" output="false">
        <cfargument name="segmentRows" type="array" required="true">
        <cfargument name="startLocation" type="string" required="true">
        <cfargument name="fallbackStartOrder" type="numeric" required="true">
        <cfscript>
            var out = { "SUCCESS"=false, "ROWS"=[], "START_ORDER"=val(arguments.fallbackStartOrder), "END_ORDER"=0 };
            var startNorm = normalizeText(arguments.startLocation);
            var n = arrayLen(arguments.segmentRows);
            var candidateStarts = [];
            var i = 0;
            var k = 0;
            var idx = 0;
            var seg = {};
            var rows = [];
            var valid = false;
            var returnsToStart = false;
            var prevSeg = {};
            var bestRows = [];
            var bestStart = 0;
            if (!len(startNorm) OR n LTE 0) return out;

            for (i = 1; i LTE n; i++) {
                if (areLocationNamesEquivalent(arguments.segmentRows[i].START_NAME, arguments.startLocation)) {
                    arrayAppend(candidateStarts, i);
                }
            }
            if (!arrayLen(candidateStarts)) return out;

            for (i = 1; i LTE arrayLen(candidateStarts); i++) {
                rows = [];
                valid = true;
                for (k = 0; k LT n; k++) {
                    idx = ((candidateStarts[i] - 1 + k) MOD n) + 1;
                    seg = arguments.segmentRows[idx];
                    if (k GT 0 AND areLocationNamesEquivalent(seg.START_NAME, arguments.startLocation)) {
                        break;
                    }
                    if (arrayLen(rows) GT 0) {
                        prevSeg = rows[arrayLen(rows)];
                        if (!areLocationNamesEquivalent(prevSeg.END_NAME, seg.START_NAME)) {
                            valid = false;
                            break;
                        }
                    }
                    arrayAppend(rows, seg);
                }
                if (!valid OR !arrayLen(rows)) {
                    continue;
                }
                returnsToStart = areLocationNamesEquivalent(rows[arrayLen(rows)].END_NAME, arguments.startLocation);
                if (!returnsToStart) {
                    continue;
                }
                if (arrayLen(rows) GT arrayLen(bestRows)) {
                    bestRows = rows;
                    bestStart = candidateStarts[i];
                }
            }

            if (arrayLen(bestRows)) {
                out.SUCCESS = true;
                out.ROWS = bestRows;
                out.START_ORDER = bestRows[1].ROUTE_ORDER;
                out.END_ORDER = bestRows[arrayLen(bestRows)].ROUTE_ORDER;
                return out;
            }
            return out;
        </cfscript>
    </cffunction>

    <cffunction name="pickBestPointToPointSelection" access="private" returntype="struct" output="false">
        <cfargument name="segmentRows" type="array" required="true">
        <cfargument name="startLocation" type="string" required="true">
        <cfargument name="endLocation" type="string" required="true">
        <cfargument name="fallbackStartOrder" type="numeric" required="true">
        <cfscript>
            var out = { "SUCCESS"=false, "ROWS"=[], "START_ORDER"=val(arguments.fallbackStartOrder), "END_ORDER"=0, "WRAP_RANGE"=false };
            var n = arrayLen(arguments.segmentRows);
            var startNorm = normalizeText(arguments.startLocation);
            var endNorm = normalizeText(arguments.endLocation);
            var candidateStarts = [];
            var i = 0;
            var k = 0;
            var idx = 0;
            var seg = {};
            var rows = [];
            var prevSeg = {};
            var valid = false;
            var reachedEnd = false;
            var bestRows = [];
            if (!len(startNorm) OR !len(endNorm) OR n LTE 0) return out;

            for (i = 1; i LTE n; i++) {
                if (areLocationNamesEquivalent(arguments.segmentRows[i].START_NAME, arguments.startLocation)) {
                    arrayAppend(candidateStarts, i);
                }
            }
            if (!arrayLen(candidateStarts)) return out;

            for (i = 1; i LTE arrayLen(candidateStarts); i++) {
                rows = [];
                valid = true;
                reachedEnd = false;
                for (k = 0; k LT n; k++) {
                    idx = ((candidateStarts[i] - 1 + k) MOD n) + 1;
                    seg = arguments.segmentRows[idx];
                    if (k GT 0 AND areLocationNamesEquivalent(seg.START_NAME, arguments.startLocation)) {
                        break;
                    }
                    if (arrayLen(rows) GT 0) {
                        prevSeg = rows[arrayLen(rows)];
                        if (!areLocationNamesEquivalent(prevSeg.END_NAME, seg.START_NAME)) {
                            valid = false;
                            break;
                        }
                    }
                    arrayAppend(rows, seg);
                    if (areLocationNamesEquivalent(seg.END_NAME, arguments.endLocation)) {
                        reachedEnd = true;
                        break;
                    }
                }
                if (!valid OR !reachedEnd OR !arrayLen(rows)) {
                    continue;
                }
                if (!arrayLen(bestRows) OR arrayLen(rows) LT arrayLen(bestRows)) {
                    bestRows = rows;
                }
            }

            if (arrayLen(bestRows)) {
                out.SUCCESS = true;
                out.ROWS = bestRows;
                out.START_ORDER = bestRows[1].ROUTE_ORDER;
                out.END_ORDER = bestRows[arrayLen(bestRows)].ROUTE_ORDER;
                if (out.END_ORDER LT out.START_ORDER) {
                    out.WRAP_RANGE = true;
                }
                return out;
            }
            return out;
        </cfscript>
    </cffunction>

    <cffunction name="areLocationNamesEquivalent" access="private" returntype="boolean" output="false">
        <cfargument name="a" type="any" required="true">
        <cfargument name="b" type="any" required="true">
        <cfscript>
            var an = normalizeText(arguments.a);
            var bn = normalizeText(arguments.b);
            if (!len(an) OR !len(bn)) return false;
            if (an EQ bn) return true;
            if (findNoCase(an, bn) GT 0 OR findNoCase(bn, an) GT 0) return true;
            return false;
        </cfscript>
    </cffunction>

    <cffunction name="normalizeText" access="private" returntype="string" output="false">
        <cfargument name="s" type="any" required="true">
        <cfscript>
            var v = lCase(trim(toString(arguments.s)));
            if (!len(v)) return "";
            v = reReplace(v, "\bst[.]?\b", "saint", "all");
            v = reReplace(v, "\bmt[.]?\b", "mount", "all");
            v = reReplace(v, "[^a-z0-9]+", " ", "all");
            v = reReplace(v, "\s+", " ", "all");
            return trim(v);
        </cfscript>
    </cffunction>

    <cffunction name="normalizeDirection" access="private" returntype="string" output="false">
        <cfargument name="direction" type="any" required="false" default="CCW">
        <cfscript>
            var d = uCase(trim(toString(arguments.direction)));
            if (d EQ "CW") return "CW";
            return "CCW";
        </cfscript>
    </cffunction>

    <cffunction name="normalizeTripType" access="private" returntype="string" output="false">
        <cfargument name="tripType" type="any" required="false" default="POINT_TO_POINT">
        <cfscript>
            var t = uCase(trim(toString(arguments.tripType)));
            if (t EQ "FULL_LOOP") return "FULL_LOOP";
            return "POINT_TO_POINT";
        </cfscript>
    </cffunction>

    <cffunction name="normalizeBuildMode" access="private" returntype="string" output="false">
        <cfargument name="mode" type="any" required="false" default="DAILY">
        <cfscript>
            var m = uCase(trim(toString(arguments.mode)));
            if (m EQ "SINGLE_MASTER") return "SINGLE_MASTER";
            return "DAILY";
        </cfscript>
    </cffunction>

    <cffunction name="toBoolean" access="private" returntype="boolean" output="false">
        <cfargument name="value" type="any" required="true">
        <cfargument name="fallback" type="boolean" required="false" default="false">
        <cfscript>
            var raw = trim(lCase(toString(arguments.value)));
            if (isBoolean(arguments.value)) return (arguments.value ? true : false);
            if (isNumeric(arguments.value)) return (val(arguments.value) NEQ 0);
            if (listFindNoCase("true,yes,y,on", raw)) return true;
            if (listFindNoCase("false,no,n,off", raw)) return false;
            if (raw EQ "1") return true;
            if (raw EQ "0") return false;
            return arguments.fallback;
        </cfscript>
    </cffunction>

    <cffunction name="getBodyJson" access="private" returntype="struct" output="false">
        <cfset var httpData = getHttpRequestData() />
        <cfset var rawBody = toString(httpData.content) />
        <cfset var body = {} />
        <cfif len(trim(rawBody))>
            <cftry>
                <cfset body = deserializeJSON(rawBody, false) />
                <cfcatch>
                    <cfset body = {} />
                </cfcatch>
            </cftry>
        </cfif>
        <cfreturn body />
    </cffunction>

    <cffunction name="pickArg" access="private" returntype="any" output="false">
        <cfargument name="body" type="struct" required="true">
        <cfargument name="fieldA" type="string" required="true">
        <cfargument name="fieldB" type="string" required="true">
        <cfargument name="fallback" type="any" required="false" default="">
        <cfif structKeyExists(arguments.body, arguments.fieldA)>
            <cfreturn arguments.body[arguments.fieldA] />
        </cfif>
        <cfif structKeyExists(url, arguments.fieldA)>
            <cfreturn url[arguments.fieldA] />
        </cfif>
        <cfif structKeyExists(arguments.body, arguments.fieldB)>
            <cfreturn arguments.body[arguments.fieldB] />
        </cfif>
        <cfif structKeyExists(url, arguments.fieldB)>
            <cfreturn url[arguments.fieldB] />
        </cfif>
        <cfreturn arguments.fallback />
    </cffunction>

    <cffunction name="pickStruct" access="private" returntype="any" output="false">
        <cfargument name="s" type="struct" required="true">
        <cfargument name="k" type="string" required="true">
        <cfargument name="fallback" type="any" required="false" default="">
        <cfif structKeyExists(arguments.s, arguments.k)>
            <cfreturn arguments.s[arguments.k] />
        </cfif>
        <cfreturn arguments.fallback />
    </cffunction>

    <cffunction name="toNullableString" access="private" returntype="struct" output="false">
        <cfargument name="v" type="any" required="true">
        <cfset var s = trim(toString(arguments.v)) />
        <cfif len(s)>
            <cfreturn { "isNull"=false, "value"=s } />
        </cfif>
        <cfreturn { "isNull"=true, "value"="" } />
    </cffunction>

    <cffunction name="toNullableNumber" access="private" returntype="struct" output="false">
        <cfargument name="v" type="any" required="true">
        <cfargument name="kind" type="string" required="false" default="numeric">
        <cfset var s = trim(toString(arguments.v)) />
        <cfset var n = 0 />
        <cfif len(s) AND isNumeric(s)>
            <cfset n = val(s) />
            <cfif arguments.kind EQ "integer">
                <cfset n = int(n) />
            </cfif>
            <cfreturn { "isNull"=false, "value"=n } />
        </cfif>
        <cfreturn { "isNull"=true, "value"=0 } />
    </cffunction>

    <cffunction name="isNullableZero" access="private" returntype="boolean" output="false">
        <cfargument name="n" type="struct" required="true">
        <cfif NOT structKeyExists(arguments.n, "isNull") OR NOT structKeyExists(arguments.n, "value")>
            <cfreturn false />
        </cfif>
        <cfreturn (NOT arguments.n.isNull AND isNumeric(arguments.n.value) AND val(arguments.n.value) EQ 0) />
    </cffunction>

    <cffunction name="resolveUserId" access="private" returntype="numeric" output="false">
        <cfargument name="userStruct" type="any" required="true">
        <cfset var uid = 0 />
        <cfif isStruct(arguments.userStruct)>
            <cfif structKeyExists(arguments.userStruct, "userId")>
                <cfset uid = val(arguments.userStruct.userId) />
            <cfelseif structKeyExists(arguments.userStruct, "USERID")>
                <cfset uid = val(arguments.userStruct.USERID) />
            <cfelseif structKeyExists(arguments.userStruct, "id")>
                <cfset uid = val(arguments.userStruct.id) />
            <cfelseif structKeyExists(arguments.userStruct, "ID")>
                <cfset uid = val(arguments.userStruct.ID) />
            </cfif>
        </cfif>
        <cfreturn uid />
    </cffunction>

    <cffunction name="getMilepointService" access="private" returntype="any" output="false">
        <cfscript>
            var svc = "";
            try {
                svc = createObject("component", "fpw.api.v1.MilepointService");
            } catch (any e1) {
                try {
                    svc = createObject("component", "api.v1.MilepointService");
                } catch (any e2) {
                    svc = "";
                }
            }
            return svc;
        </cfscript>
    </cffunction>

    <cffunction name="roundTo2" access="private" returntype="numeric" output="false">
        <cfargument name="n" type="numeric" required="true">
        <cfreturn (round(arguments.n * 100) / 100) />
    </cffunction>

</cfcomponent>
